#+title: Ematrix (personal emacs configuration)
#+author: donney
#+startup: overview

* Introduction
Customising an editor can be very rewarding ... until you have to leave it.
For years I have been looking for ways to avoid this pain.
Then I discovered [[https://github.com/cknadler/vim-anywhere][vim-anywhere]], and found that it had an Emacs companion,
[[https://github.com/zachcurry/emacs-anywhere][emacs-anywhere]]. To me, this looked most attractive.

Separately, online I have seen the following statement enough times I think it's a catchphrase
#+begin_quote
Redditor 1: I just discovered this thing, isn't it cool. \\
Redditor 2: Oh, there's an Emacs mode for that.
#+end_quote

This was enough for me to install Emacs, but I soon learned there are [[https://github.com/remacs/remacs#why-emacs][far more
compelling reasons]] to keep using it.

I tried out the =spacemacs= distribution a bit, but it wasn't quite to my liking.
Then I heard about =doom emacs= and thought I may as well give that a try.
TLDR; it's great.

Now I've discovered the wonders of literate programming, and am becoming more
settled by the day. This is both my config, and a cautionary tale (just replace
"Linux" with "Emacs" in the comic below).

[[xkcd:456]]

** Why Emacs?
Emacs is [[https://www.eigenbahn.com/2020/01/12/emacs-is-no-editor][not a text editor]], this is a common misnomer. It is far more apt to
describe Emacs as /a Lisp machine providing a generic user-centric text
manipulation environment/. That's quite a mouthful.
In simpler terms one can think of Emacs as a platform for text-related
applications. It's a vague and generic definition because Emacs itself is
generic.

Good with text. How far does that go? A lot further than one initially thinks:
+ [[https://orgmode.org/][Task planning]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][File management]]
+ [[https://github.com/akermu/emacs-libvterm][Terminal emulation]]
+ [[https://www.djcbsoftware.nl/code/mu/mu4e.html][Email client]]
+ [[https://www.gnu.org/software/tramp/][Remote server tool]]
+ [[https://magit.vc/][Git frontend]]
+ Web [[https://github.com/pashky/restclient.el][client]]/[[https://github.com/skeeto/emacs-web-server][server]]
+ and more...

Ideally, one may use Emacs as /the/ interface to perform =input → transform →
output= cycles, i.e. form a bridge between the human mind and information
manipulation.

*** The enveloping editor
Emacs allows one to do more in one place than any other application. Why is this
good?
+ Enables one to complete tasks with a consistent, standard set of keybindings,
  GUI and editing methods --- learn once, use everywhere
+ Reduced context-switching
+ Compressing the stages of a project --- a more centralised workflow can progress
  with greater ease
+ Integration between tasks previously relegated to different applications, but
  with a common subject --- e.g. linking to an email in a to-do list

Emacs can be thought of as a platform within which various elements of your
workflow may settle, with the potential for rich integrations between them --- a
/life/ IDE if you will.

Today, many aspects of daily computer usage are split between different
applications which act like islands, but this often doesn't mirror how we
/actually use/ our computers. Emacs, if one goes down the rabbit hole, can give
users the power to bridge this gap.

#+name: emacs-platform
#+begin_src dot :file misc/emacs-platform.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [arrowhead=none color="#aaaaaa" penwidth="1.2"]
    // nodes
    "Task Managment" [color="#2ec27e"]
    "Email" [color="#1c71d8"]
    "Office suite" [color="#813d9c"]
    "Code editor" [color="#f5c211"]
    "Git client" [color="#e66100"]
    // "News feed" [color="#c01c28"]
    // "Personal Knowledge Base" [color="#986a44"]

    "Task Managment" -> "Email"
    "Task Managment" -> "Office suite"
    "Task Managment" -> "Code editor"
    "Task Managment" -> "Git client"
    // "Task Managment" -> "News feed"
    // "Task Managment" -> "Personal Knowledge Base"

    "Email" -> "Office suite"
    "Email" -> "Code editor"
    "Email" -> "Git client"
    // "Email" -> "Personal Knowledge Base"

    "Office suite" -> "Code editor"
    "Office suite" -> "Git client"
    // "Office suite" -> "News feed"
    // "Office suite" -> "Personal Knowledge Base"

    "Code editor" -> "Git client"

    // "News feed" -> "Personal Knowledge Base"
}
#+end_src

#+caption: Some sample workflow integrations that can be used within Emacs
#+attr_html: :class invertible :alt Graph of possible Emacs task integrations :style max-width:min(24em,100%)
#+attr_latex: :width 0.55\linewidth
[[file:misc/emacs-platform.svg]]

*** Some notably unique features
+ Recursive editing
+ Completely introspectable, with pervasive docstrings
+ Mutable environment, which can be incrementally modified
+ Functionality without applications
+ Client-server separation allows for a daemon, giving near-instant perceived
  startup time.

*** Issues
+ Emacs has irritating quirks
+ Some aspects are showing their age (naming conventions, APIs)
+ Emacs is ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html][mostly]]) single-threaded, meaning that when something holds that
  thread up the whole application freezes
+ A few other nuisances

*** Teach a man to fish...
#+begin_quote
Give a man a fish, and you feed him for a day. Teach a man to fish, and you feed
him for a lifetime. --- Anne Isabella
#+end_quote

Most popular editors have a simple and pretty [[https://code.visualstudio.com/docs/getstarted/settings][settings interface]], filled with
check-boxes, selects, and the occasional text-box. This makes it easy for the
user to pick between common desirable behaviours. To me this is now like /giving
a man a fish/.

What if you want one of those 'check-box' settings to be only on in certain
conditions? Some editors have workspace settings, but that requires you to
manually set the value for /every single instance/. Urgh, [[https://github.com/microsoft/vscode/issues/93153][what]] [[https://github.com/microsoft/vscode/issues/93628][a]] [[https://github.com/microsoft/vscode/issues/5595][pain]].

What if you could set the value of that 'check-box' setting to be the result of
an arbitrary expression evaluated for each file? This is where an editor like
Emacs comes in.
Configuration for Emacs isn't a list of settings in JSON etc. it's *an executable
program which modifies the behaviour of the editor to suit your liking*.
This is 'teaching a man to fish'.

Emacs is built in the same language you configure it in (Emacs [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp]], or [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][elisp]]).
It comes with a broad array of useful functions for text-editing, and Doom adds
a few handy little convenience functions.

Want to add a keybinding to delete the previous line? It's as easy as
#+name: Keybinding to delete the previous line
#+begin_src emacs-lisp :tangle no
(map! "C-d"
      (cmd! (previous-line)
            (kill-line)
            (forward-line)))
#+end_src

How about another example, say you want to be presented with a list of currently
open /buffers/ (think files, almost) when you split the window. It's as simple as
#+name: Prompt for buffer after split
#+begin_src emacs-lisp :tangle no
(defadvice! prompt-for-buffer (&rest _)
  :after 'window-split (switch-to-buffer))
#+end_src

Want to test it out? You don't need to save and restart, you can just /evaluate
the expression/ within your current Emacs instance and try it immediately! This
editor is, after all, a Lisp interpreter.

Want to tweak the behaviour? Just re-evaluate your new version --- it's a
super-tight iteration loop.

** Editor comparison

[[xkcd:378]]

Over the years I have tried out (spent at least a year using as my primary
editor) the following applications
- Python IDLE
- Komodo Edit
- Brackets
- VSCode
- and now, Emacs

I have attempted to quantify aspects of my impressions of them below.

#+plot: transpose:yes type:radar min:0 max:4 ticks:4 file:"misc/editor-comparison.svg"
| Editor      | Extensibility | Ecosystem | Ease of Use | Comfort | Completion | Performance |
|-------------+---------------+-----------+-------------+---------+------------+-------------|
| IDLE        |             1 |         1 |           3 |       1 |          1 |           2 |
| VSCode      |             3 |         3 |           4 |     3.5 |          4 |           3 |
| Brackets    |           2.5 |         2 |           3 |       3 |        2.5 |           2 |
| Emacs       |             4 |         4 |           2 |       4 |        3.5 |           3 |
| Komodo Edit |             2 |         1 |           3 |       2 |          2 |           2 |

#+attr_html: :class invertible :alt Radar chart comparing my thoughts on a few editors.
#+attr_latex: :options inkscapelatex=false
[[file:misc/editor-comparison.svg]]

** Notes for the unwary adventurer
If you like the look of this, that's marvellous, and I'm really happy that I've
made something which you may find interesting, however:
#+begin_warning
This config is /insidious/. Copying the whole thing blindly can easily lead to
undesired effects. I recommend copying chunks instead.
#+end_warning

If you are so bold as to wish to steal bits of my config (or if I upgrade and
wonder why things aren't working), here's a list of sections which rely on
external setup (i.e. outside of this config).

+ dictionary :: I've downloaded a custom [[http://app.aspell.com/create][SCOWL]] dictionary, which I use in [[*Ispell][ispell]].
  If this causes issues, just delete the src_elisp{(setq ispell-dictionary ...)}
  bit.

Oh, did I mention that I started this config when I didn't know any =elisp=, and
this whole thing is a hack job? If you can suggest any improvements, please do
so, no matter how much criticism you include I'll appreciate it :)

[[xkcd:1513]]

*** Extra Requirements
The lovely ~doom doctor~ is good at diagnosing most missing things, but here are a
few extras.
+ A [[https://www.tug.org/texlive/][LaTeX Compiler]] is required for the mathematics rendering performed in [[#org][Org]],
  and by [[*CalcTeX][CalcTeX]].
+ I use the [[https://overpassfont.org/][Overpass]] font as a go-to sans serif.
  It's used as my ~doom-variable-pitch-font~ and in the graph generated
  by [[*Roam][Roam]].
  I have chosen it because it possesses a few characteristics I consider
  desirable, namely:
  - A clean, and legible style. Highway-style fonts tend to be designed to be
    clear at a glance, and work well with a thicker weight, and this is inspired
    by /Highway Gothic/.
  - It's slightly quirky. Look at the diagonal cut on stems for example.
    Helvetica is a masterful design, but I like a bit more pizzazz now and then.
+ A few LSP servers. Take a look at [[file:init.el][init.el]] to see which modules have the ~+lsp~ flag.
** Current Issues
*** Magit push in daemon
Quite often trying to push to a remote in the Emacs daemon produces as error like this:
#+begin_src fundamental
128 git … push -v origin refs/heads/master\:refs/heads/master
Pushing to git@github.com:tecosaur/emacs-config.git

fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src
*** Unread emails doesn't work across Emacs instances
It would be nice if it did, so that I could have the Emacs-daemon hold the
active mu4e session, but still get that information. In this case I'd want to
change the action to open the Emacs daemon, but it should be possible.

This would probably involve hooking into the daemon's modeline update function
to write to a temporary file, and having a file watcher started in other Emacs
instances, in a similar manner to [[*Rebuild mail index while using mu4e][Rebuild mail index while using mu4e]].
* Config
** logo
#+name: logo
#+begin_src emacs-lisp
;;;
;;; ___________               __         .__
;;; \_   _____/ _____ _____ _/  |________|__|__  ___
;;;  |    __)_ /     \\__  \\   __\_  __ \  \  \/  /
;;;  |        \  Y Y  \/ __ \|  |  |  | \/  |>    <
;;; /_______  /__|_|  (____  /__|  |__|  |__/__/\_ \
;;;         \/      \/     \/                     \/
;;;
;;; MINIMALIST & LIGHTWEIGHT EMACS CONFIGURATION FRAMEWORK
;;; donneyluck.github.io/ematrix
;;;
;;; Author: donneyluck@gmail.com
;;; Copyright (C) 2022-2026  Machine Studio
;;;
#+end_src

** early-init.el
:properties:
:header-args: :tangle no :noweb yes
:end:
*** header
#+begin_src emacs-lisp
;;; early-init.el ---  early initialization tweaks -*- lexical-binding: t; -*-
<<logo>>
;;; Commentary:
;;; Code:
#+end_src

*** early initialization tweaks
#+begin_src emacs-lisp
(setq
 ;; Do not make installed packages available when Emacs starts (we use `straight')
 package-enable-at-startup nil
 ;; Avoid garbage collections in the startup phase, this will be overwritten by the `me-gc' core module
 gc-cons-threshold most-positive-fixnum
 ;; Prefer loading newer files
 load-prefer-newer t
 ;; Remove some unneeded UI elements
 default-frame-alist '((tool-bar-lines . 0)
                       (menu-bar-lines . 0)
                       (vertical-scroll-bars)
                       (left-fringe . 8)
                       (right-fringe . 13)
                       (internal-border-width . 15)
                       (mouse-color . "blue")
                       (fullscreen . maximized))
 ;; Explicitly set modes disabled in `default-frame-alist' to nil
 tool-bar-mode nil
 menu-bar-mode nil
 scroll-bar-mode nil
 ;; Set mode-line format to prevent it from showing at startup
 mode-line-format nil)

;; It seems like, even when `tool-bar-mode' is nil, `tool-bar-setup' still be called
(advice-add 'tool-bar-setup :override #'ignore)

;; NOTE: In Emacs29+, frames can have a transparent background via the
;; `alpha-background' parameter. For a better experience, this value should be
;; set early before any frame gets created (i.e. in "early-init.el"). Ematrix
;; uses the `$EMATRIX_ALPHA` environment variable that can be set to an integer
;; value in the [1-100] range (the alpha percentage). When this variable is not
;; set, Emacs will load the default GUI (without background alpha), and when it
;; is set but the value is not valid, Ematrix will fallback to the default
;; alpha of 93%.
(when (>= emacs-major-version 29)
  (when-let* ((alpha (getenv "EMATRIX_ALPHA"))
              (alpha (string-to-number alpha)))
    (push `(alpha-background . ,(if (or (zerop alpha) (> alpha 100)) 93 alpha)) default-frame-alist)))

;; Load Ematrix variables from the `me-vars' core module.
(load (expand-file-name "core/me-vars.el" (file-name-directory (file-truename load-file-name))) nil t)

;; Better titlebar on MacOS!
(when (and os/mac (featurep 'ns))
  (push '(ns-transparent-titlebar . t) default-frame-alist))

;; Load the user early configuration files
(+load-user-configs 'early-config 'local/early-config)

;;; early-init.el ends here
#+end_src

** init.el
:properties:
:header-args: :tangle init.el :noweb yes
:end:
*** header
#+begin_src emacs-lisp
;; init.el --- Ematrix core initialization file -*- lexical-binding: t; -*-
<<logo>>
;;; Commentary:
#+end_src

*** load and hooks order
#+begin_src emacs-lisp
;; # Ematrix - a minimalist & lightweight Emacs configuration framework
;;
;; Load and hooks order:
;; - `~/.emacs.d/early-init.el`
;; - `$EMATRIXDIR/early-config.el` (unless disabled in `$EMATRIX_IGNORE_USER_CONFIG`)
;; - `$EMATRIXDIR/local/early-config.el` (unless disabled)
;; - `~/.emacs.d/init.el`
;;   * `before-init-hook'
;;   * `~/.emacs.d/core/me-vars.el`
;;   * `~/.emacs.d/core/backports/*.el` (when Emacs < 29)
;;   * `~/.emacs.d/core/me-loaddefs.el`
;;   * `$EMATRIXDIR/init-tweaks.el` (unless disabled)
;;   * `$EMATRIXDIR/local/init-tweaks.el` (unless disabled)
;;   * `$EMATRIXDIR/modules.el` (unless disabled)
;;   * `$EMATRIXDIR/local/modules.el` (unless disabled)
;;   * `~/.emacs.d/core/<module>.el`
;;   * `~/.emacs.d/modules/<module>.el` (for module in `ematrix-modules')
;;   * `ematrix-after-loading-modules-hook'
;;   * `$EMATRIXDIR/custom-vars.el`
;;   * `$EMATRIXDIR/config.el` (unless disabled)
;;   * `$EMATRIXDIR/local/config.el` (unless disabled)
;;   * `after-init-hook'
;;   * `emacs-startup-hook'
;;   * `ematrix-after-startup-hook'
;;     + `ematrix-lazy-hook' (delayed)

;; Special hooks defined with `+make-first-file-hook!'
;; - `ematrix-first-file-hook'
;; - `ematrix-first-elisp-file-hook'
;; - `ematrix-first-python-file-hook'
;; - `ematrix-first-org-file-hook'
;; - `ematrix-first-c/c++-file-hook'

;;; Code:
#+end_src

*** benchmark
#+begin_src emacs-lisp
;; Run a profiling session if `$EMATRIX_BENCHMARK' is defined.
(when (getenv "EMATRIX_BENCHMARK")
  (let ((dir (concat (file-name-directory load-file-name) "elisp/benchmark-init/")))
    (if (not (file-exists-p (concat dir "benchmark-init.el")))
        (error "[Ematrix:Error] `benchmark-init' is not available, make sure you've run \"git submodule update --init\" inside Ematrix' directory")
      (add-to-list 'load-path dir)
      (require 'benchmark-init)
      (benchmark-init/activate)

      (defun +benchmark-init--desactivate-and-show-h ()
        (benchmark-init/deactivate)
        (require 'benchmark-init-modes)
        (benchmark-init/show-durations-tree))

      (with-eval-after-load 'me-vars
        (add-hook 'ematrix-lazy-hook #'+benchmark-init--desactivate-and-show-h 99)))))
#+end_src

*** check version
#+begin_src emacs-lisp
(let ((min-ver 29))
  (when (< emacs-major-version min-ver)
    (error "Emacs v%s is not supported, Ematrix requires v%s or higher" emacs-version min-ver)))
#+end_src

*** performance
#+begin_src emacs-lisp
;; PERF: Setting `file-name-handler-alist' to nil should boost startup time.
;; reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start
;; Store the current value so we can reset it after Emacs startup.
(put 'file-name-handler-alist 'original-value (default-toplevel-value 'file-name-handler-alist))
;; Make sure the new value survives any current let-binding.
(set-default-toplevel-value 'file-name-handler-alist nil)
;; After Emacs startup, we restore `file-name-handler-alist' while conserving
;; the potential new elements made during startup.
(defun +mineamcs--restore-file-name-handler-alist-h ()
  (setq file-name-handler-alist (delete-dups (append file-name-handler-alist (get 'file-name-handler-alist 'original-value)))))
(add-hook 'emacs-startup-hook '+mineamcs--restore-file-name-handler-alist-h 99)
#+end_src

*** vars
#+begin_src emacs-lisp
;; HACK: At this point, Ematrix variables defined in `me-vars' should be
;; already loaded (in "early-init.el"). However, we double-check here and load
;; them if necessary in case Emacs has been loaded directly from "init.el"
;; without passing by "early-init.el". This can happen when we are running in a
;; `me-org-export-async-init' context, or if we use some bootstrapping mechanism
;; like Chemacs2.
(unless (featurep 'me-vars)
  (load (expand-file-name "core/me-vars.el" (file-name-directory (file-truename load-file-name))) nil t))
#+end_src

*** path
#+begin_src emacs-lisp
;; Add some of Ematrix' directories to `load-path'.
(setq load-path (append (list ematrix-core-dir ematrix-elisp-dir ematrix-extras-dir ematrix-modules-dir) load-path))

;; HACK: Most Emacs' builtin and third-party packages depends on the
;; `user-emacs-directory' variable to store cache information, generated
;; configuration files and downloaded utilities. However, this will mess with
;; Ematrix' directory (which defaults to `user-emacs-directory'). To keep the
;; "~/.emacs.d/" directory clean, we overwrite the `user-emacs-directory' at
;; early stage with `ematrix-local-dir' so all generated files gets stored in
;; "~/.emacs.d/local/".
;; NOTE: It is important to set this here and not in `me-vars' nor in
;; "early-init.el", otherwise, it won't work with Chemacs2-based installations.
(setq user-emacs-directory ematrix-local-dir)
#+end_src

*** lib
#+begin_src emacs-lisp
(require 'me-lib)
#+end_src

*** NO compatibility
#+begin_src emacs-lisp :tangle no
;; HACK: Load Emacs 29 back ports for earlier Emacs versions. Note that I do
;; only back port a very small number of the functions/variables that I use at
;; early stage from Emacs29+ to be compatible with Emacs 28.2. For any Emacs
;; version less than 29, Ematrix will enable the `me-compat' module and load it
;; just after `me-bootstrap'. This module loads the `compat' package which
;; provide several forward compatibility functions, it is loaded at an early
;; stage to provide its functionality to the rest of the modules so we can use
;; some new features when configuring them.
(when (< emacs-major-version 29)
  (let ((backports-dir (concat ematrix-core-dir "backports/")))
    (mapc (apply-partially #'+load backports-dir) (directory-files backports-dir nil "\\.el\\'"))))
#+end_src

*** debug
#+begin_src emacs-lisp
(setq
 ;; Enable debugging on error when Emacs is launched with the `--debug-init`
 ;; option or when the environment variable `$EMATRIX_DEBUG` is defined (see
 ;; `me-vars').
 debug-on-error ematrix-debug-p
 ;; Decrease the warning type to `:error', unless we are running in verbose mode
 warning-minimum-level (if ematrix-verbose-p :warning :error)
 warning-minimum-log-level warning-minimum-level
 ;; Make byte compilation less noisy
 byte-compile-warnings ematrix-verbose-p
 byte-compile-verbose ematrix-verbose-p)
 #+end_src

*** native compilation
#+begin_src emacs-lisp
;; Native compilation settings
(when (featurep 'native-compile)
  (setq
   ;; Silence compiler warnings as they can be pretty disruptive, unless we are
   ;; running in `ematrix-verbose-p' mode.
   native-comp-async-report-warnings-errors (when ematrix-verbose-p 'silent)
   native-comp-verbose (if ematrix-verbose-p 1 0) ; do not be too verbose
   native-comp-debug (if ematrix-debug-p 1 0)
   ;; Make native compilation happens asynchronously.
   native-comp-jit-compilation t)

  ;; Set the right directory to store the native compilation cache to avoid
  ;; messing with "~/.emacs.d/".
  (startup-redirect-eln-cache (concat ematrix-cache-dir "eln/")))
#+end_src

*** autoload
#+begin_src emacs-lisp
(defun ematrix-generate-loaddefs ()
  "Generate Ematrix' loaddefs file."
  (interactive)
  (when (file-exists-p ematrix-loaddefs-file) (delete-file ematrix-loaddefs-file))
  (apply (if (fboundp 'loaddefs-generate) #'loaddefs-generate #'make-directory-autoloads)
         (list (list ematrix-core-dir ematrix-elisp-dir ematrix-extras-dir) ematrix-loaddefs-file)))

;; Some of Ematrix commands and libraries are defined to be auto-loaded. In
;; particular, these in the `ematrix-core-dir', `ematrix-elisp-dir', and
;; `ematrix-extras-dir' directories. The generated loaddefs file will be stored
;; in `ematrix-loaddefs-file'. We first regenerate the loaddefs file if it
;; doesn't exist.
(unless (file-exists-p ematrix-loaddefs-file) (ematrix-generate-loaddefs))

;; Then we load the loaddefs file
(+load ematrix-loaddefs-file)
#+end_src

*** user tweak
#+begin_src emacs-lisp
;; Load user init tweaks when available
(+load-user-configs 'init-tweaks 'local/init-tweaks)
#+end_src

*** proxy
#+begin_src emacs-lisp
;; When `ematrix-proxies' is set in "early-init.el" or in "init-tweaks.el",
;; `ematrix-enable-proxy' will set the environment variables accordingly.
(unless ematrix-no-proxies-p (ematrix-enable-proxy ematrix-proxies))
#+end_src

*** env
#+begin_src emacs-lisp
;; HACK: Load the environment variables saved from shell using `+env-save' to
;; `+env-file'. `+env-save' saves all environment variables except these matched
;; by `+env-deny-vars'.
(+env-load) ; Load environment variables when available.
#+end_src

*** hook
#+begin_src emacs-lisp
(defun +ematrix--loaded-h ()
  "This is Ematrix' synchronization point.

To achieve fast Emacs startup, we try to defer loading most of
the packages until this hook is executed. This is managed by the
`ematrix-loaded' and `ematrix-lazy' features.

After loading Emacs, the `emacs-startup-hook' gets executed, we
use this hook to profile the startup time, and load the theme.
Lastly we require the `ematrix-loaded' synchronization module,
which runs the `ematrix-after-startup-hook' hooks and provide
`ematrix-loaded' so the packages loaded with `:after
ematrix-loaded' can be loaded.

The `ematrix-loaded' will require `ematrix-lazy', which
incrementally run the hooks in `ematrix-lazy-hook' after
startup, and at the end, provide the `ematrix-lazy' feature so
the packages loaded with `:after ematrix-lazy' can be loaded."
  (+info! "Loaded Emacs%s in %s, including %.3fs for %d GCs." (if (daemonp) " (in daemon mode)" "") (emacs-init-time) gc-elapsed gcs-done)
  (unless (featurep 'me-org-export-async-init) (+load-theme))
  (require 'ematrix-loaded))

;; Add it to the very beginning of `emacs-startup-hook'
(add-hook 'emacs-startup-hook #'+ematrix--loaded-h -91)

;; ========= Make some special hooks =========
(+make-first-file-hook! 'org "\\.org$")
(+make-first-file-hook! 'elisp "\\.elc?$")
(+make-first-file-hook! 'python (rx "." (or "py" "pyw" "pyx" "pyz" "pyzw") eol))
(+make-first-file-hook! 'c/c++ (rx "." (or "c" "cpp" "cxx" "cc" "c++" "h" "hpp" "hxx" "hh" "h++" "ixx" "cppm" "cxxm" "c++m" "ccm") eol))
(+make-first-file-hook! 'csharp "\\.cs$")
(+make-first-file-hook! nil ".")
#+end_src

*** package & customization
#+begin_src emacs-lisp
;; ========= Load Ematrix packages and user customization =========
;; When running in an async Org export context, the used modules are set in
;; modules/extras/me-org-export-async-init.el, so we must not override them with
;; the user's enabled modules.
(if (featurep 'me-org-export-async-init)
    (progn (message "Loading \"init.el\" in an org-export-async context.")
           (setq ematrix-not-lazy-p t))
  ;; Load the default list of enabled modules `ematrix-modules'
  (+load ematrix-core-dir "me-modules.el")
  (+load-user-configs 'modules 'local/modules))

;; When the EMATRIX_LOAD_ALL_MODULES environment variable is set, we force
;; loading all modules.
(when ematrix-load-all-modules-p
  (setq ematrix-modules (ematrix-modules)))

;; DELETE
;; (when (bound-and-true-p ematrix-core-modules)
;;   (message "[Ematrix:Warn] The `me-completion', `me-keybindings' and `me-evil' modules have been moved to `ematrix-modules'. The `ematrix-core-modules' variable is now obsolete."))

;; ;; Ematrix 7.0.0 uses only `ematrix-modules'. The `ematrix-core-modules' is left for now just to ensure compatibility.
;; (setq ematrix-modules (cl-delete-if (+apply-partially-right #'memq '(me-splash me-bootstrap me-builtin me-compat me-gc))
;;                                      (delete-dups (append (bound-and-true-p ematrix-core-modules) ematrix-modules))))

;; Load modules
(mapc #'+load (mapcar (apply-partially #'format "%s%s.el" ematrix-core-dir) '(me-bootstrap me-compat me-builtin me-gc)))
(mapc #'+load (mapcar (apply-partially #'format "%s%s.el" ematrix-modules-dir) ematrix-modules))

;; Run hooks
(run-hooks 'ematrix-after-loading-modules-hook)

;; Write user custom variables to separate file instead of "init.el"
(setq custom-file (concat ematrix-config-dir "custom-vars.el"))

;; Load the custom variables file if it exists
(when (file-exists-p custom-file) (+load custom-file))

;; Load user configuration
(+load-user-configs 'config 'local/config)

(+log! "Loaded init.el")

(put 'dired-find-alternate-file 'disabled nil)
;;; init.el ends here
#+end_src

** core
*** me-bootstrap.el
:properties:
:header-args: :tangle core/me-bootstrap.el :noweb yes :mkdirp yes
:end:
#+begin_src emacs-lisp
;;  me-bootstrap.el --- Bootstrap packages (straight & use-package) -*- lexical-binding: t; -*-
<<logo>>
;;; Commentary:
;;; Code:
(setq
 ;; Base directory
 straight-base-dir ematrix-local-dir
 ;; Add Emacs version and the Git hash to the build directory to avoid problems
 straight-build-dir (format "build-%s%s" emacs-version (if emacs-repository-version (format "-%s" (substring emacs-repository-version 0 8)) ""))
 ;; Use the "develop" branch on straight.el's repo.
 straight-repository-branch "develop"
 ;; Do not slow startup by checking for package modifs, check only on demand
 straight-check-for-modifications '(check-on-save find-when-checking))

;; Bootstrapping straight.el
;; See: github.com/radian-software/straight.el#bootstrapping-straightel
(defvar bootstrap-version)
(let ((bootstrap-file (concat straight-base-dir "straight/repos/straight.el/bootstrap.el"))
      (install-url "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el")
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer (url-retrieve-synchronously install-url 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; Configure `use-package'
(unless (require 'use-package nil t)
  (straight-use-package 'use-package))

(setq
 ;; Set `use-package' to verbose when Ematrix is started in verbose mode
 use-package-verbose (cond (ematrix-debug-p 'debug) (ematrix-verbose-p t))
 ;; Defer loading packages by default, use `:demand' to force loading a package
 use-package-always-defer (not ematrix-always-demand-p)
 use-package-always-demand ematrix-always-demand-p
 ;; Make the expanded code as minimal as possible, do not try to catch errors
 use-package-expand-minimally (not ematrix-debug-p))

;; Add the `:pin-ref' extension to integrate `straight' with `use-package'. And
;; add support for `ematrix-disabled-packages'.
(require 'me-use-package-extra)

;; Extra utilities
;; Be cautious about the installed revision of `once' and `satch' as they aren't stable yet
(use-package once
  :straight (:host github :repo "emacs-magus/once")
  :pin-ref "a6f950c29c846a50018bc63695f24f611c1a58be")

(use-package satch
  :straight (:host github :repo "emacs-magus/satch.el")
  :pin-ref "77993b711cccf16702fdc8d21d8f8ba10d7bd0fb")

(provide 'me-bootstrap)
;;; me-bootstrap.el ends here
#+end_src
*** me-builtin.el
:properties:
:header-args: :tangle core/me-builtin.el :noweb yes :mkdirp yes
:end:
**** header
#+begin_src emacs-lisp
;;; me-builtin.el --- Emacs built-in packages -*- lexical-binding: t; -*-
<<logo>>
#+end_src

**** package ~emacs~
#+begin_src emacs-lisp
(use-package emacs
  :hook (after-save . +save--guess-file-mode-h)
  :hook (minibuffer-setup . cursor-intangible-mode) ; See the `minibuffer-prompt-properties' below
  :custom
  ;; ====== Default directories for builtin packages ======
  (auto-save-list-file-prefix (+directory-ensure ematrix-local-dir "auto-save/"))
  (backup-directory-alist (list (cons "." (+directory-ensure ematrix-local-dir "backup/"))))
  (custom-theme-directory (concat ematrix-config-dir "themes/"))
  (diary-file (concat ematrix-local-dir "diary"))
  (eww-bookmarks-directory (+directory-ensure ematrix-local-dir "eww/bookmarks/"))
  (remember-data-directory (+directory-ensure ematrix-local-dir "remember/"))

  ;; ====== Better defaults ======
  (auto-save-default t) ; Enable auto-save (use `recover-file' or `recover-session' to recover)
  (auto-save-file-name-transforms ; Set file naming transform for `auto-save'
   `(;; Prefix tramp autosaves with "tramp-"
     ("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(concat auto-save-list-file-prefix "tramp-\\2") sha1)
     ;; Local autosaves
     (".*" ,auto-save-list-file-prefix sha1)))
  (auto-window-vscroll nil) ; Do not adjust window-vscroll to view tall lines. Fixes some lag issues: emacs.stackexchange.com/a/28746
  (scroll-preserve-screen-position t) ; Keep the point in the same position while scrolling
  (scroll-conservatively 101) ; Do not move cursor to the center when scrolling
  (scroll-margin 2) ; Scroll at a margin of one line
  (create-lockfiles nil) ; Disable lockfiles
  (make-backup-files t) ; Enable making backup files
  (version-control t) ; Number each backup file
  (backup-by-copying t) ; Copy instead of renaming current file
  (delete-old-versions t) ; Clean up after itself
  (tab-always-indent 'complete) ; Make TAB indents first, then inserts the TAB character
  (tab-first-completion 'word) ; TAB completion behavior
  (require-final-newline t) ; End files with newline
  (undo-limit 20000000) ; 20MB, undo data (per-buffer?) to keep (def. 160kB)
  (undo-strong-limit 5000000) ; 5MB, discard undo data greater than this generated by a single a command, except the last one (def. 240kB)
  (undo-outer-limit 30000000) ; 30MB, like the strong limit, but including the last command, prints a warning when it happens (def. 24MB)
  (use-system-tooltips nil) ; Use small frames to display tooltips instead of the default OS tooltips
  (window-combination-resize t) ; Resize window combinations proportionally
  (x-stretch-cursor t) ; Stretch cursor to the glyph width
  (frame-resize-pixelwise t) ; Do force frame size to be a multiple of char size
  (read-process-output-max ; Increase single chunk bytes to read from subprocess (def. 4096)
   (if os/linux (condition-case nil ; Android may raise permission-denied error
                    (with-temp-buffer ; On GNU/Linux systems, the value should not exceed `pipe-max-size'
                      (insert-file-contents "/proc/sys/fs/pipe-max-size")
                      (string-to-number (buffer-string)))
                  (error read-process-output-max)) ; Fallback to the default value in case of an error
     (* 1024 1024)))
  (completion-ignore-case t) ; Ignore case when completing
  (read-buffer-completion-ignore-case t)
  (read-file-name-completion-ignore-case t) ; Ignores case when completing files names
  (read-extended-command-predicate #'command-completion-default-include-p) ; In `M-x', hide commands not relevant for the current mode
  (completions-detailed t) ; More info on completions
  (enable-recursive-minibuffers t) ; Enable recursive calls to minibuffer
  (minibuffer-prompt-properties ; Do not allow the cursor in the minibuffer prompt (works with `cursor-intangible-mode')
   '(read-only t cursor-intangible t face minibuffer-prompt))
  (sentence-end-double-space nil) ; Use single space between sentences
  (delete-by-moving-to-trash t) ; Move stuff to trash
  (save-some-buffers-default-predicate #'save-some-buffers-root) ; Save files only in sub-directories of current project
  (inhibit-startup-screen t) ; Inhibit startup message
  (initial-scratch-message nil) ; No initial scratch message
  (initial-major-mode 'fundamental-mode) ; Set initial buffer to fundamental-mode for faster load
  (large-file-warning-threshold (* 20 1024 1024)) ; Increase the large file threshold to 20MiB (10MB)
  (use-dialog-box nil) ; Always prompt in minibuffer (no GUI)
  (use-short-answers t) ; Use y or n instead of yes or no
  (confirm-kill-emacs #'y-or-n-p) ; Confirm before quitting
  (prettify-symbols-unprettify-at-point t) ; Show unprettified symbol under cursor (when in `prettify-symbols-mode')
  (display-fill-column-indicator-character ?\u250a) ; Use a dashed line for `display-fill-column-indicator-mode'
  (apropos-do-all t) ; Make apropos commands search more extensively
  (vc-follow-symlinks t) ; Do not ask obvious questions, follow symlinks
  (shell-kill-buffer-on-exit t) ; Kill the shell buffer after exit
  (widget-image-enable nil) ; No ugly button for widgets
  (tooltip-hide-delay 20) ; Make tooltips last a bit longer (default 10s)
  (image-animate-loop t) ; Animated images loop forever instead of playing the animation only once
  :init
  (setq-default truncate-lines nil ; Don't truncate long line, display them
                fill-column 80 ; Default fill column width
                tab-width 4 ; Default (8) is too big!
                cursor-type 'bar) ; Use a bar by default, this can be changed by other modes (`evil', `god-mode', etc.)

  ;; Inhibit startup message in echo area the brutal way!
  ;; The `inhibit-startup-echo-area-message' variable is very restrictive, there is only one unique way of setting it right!
  ;; See: reddit.com/r/emacs/comments/6e9o4o/comment/di8q1t5
  (fset 'display-startup-echo-area-message #'ignore)
  (fset 'display-startup-screen #'ignore)

  ;;; Why use anything but UTF-8?
  (prefer-coding-system 'utf-8)
  (set-charset-priority 'unicode)
  (set-default-coding-systems 'utf-8)
  ;; I mainly write in English and French. "Latin-1" is suitable for major Western Europe languages
  (set-language-environment "Latin-1")
  (set-locale-environment "en_US.UTF-8")
  ;; Use UTF-16-LE in Windows, see: rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows
  (set-selection-coding-system (if os/win 'utf-16-le 'utf-8))
  :config
  ;; Make `ESC' behave like `C-g'
  (keymap-global-set "<escape>" #'keyboard-escape-quit)

  ;; Unbind some annoying commands
  (keymap-global-unset "C-z" 'remove)
  (keymap-global-unset "C-x C-z" 'remove)

  ;; Remap some keys/page
  (keymap-global-set "C-c f" #'recentf) ; Instead of `find-file-read-only'
  (keymap-global-set "C-c D" #'+delete-this-file-and-buffer)
  (keymap-global-set "C-x k" #'kill-current-buffer) ; Instead of `kill-buffer'
  (keymap-global-set "<f1>" #'shell) ; Instead of `help-map' (accessible via `C-h')
  (keymap-global-set "C-w" #'+kill-region-or-backward-word) ; Instead of `kill-region'
  (keymap-global-set "<remap> <kill-region>" #'+kill-region-or-backward-word) ; C-w
  (keymap-global-set "<remap> <kill-word>" #'+kill-whitespace-or-word) ; M-d
  (keymap-global-set "<remap> <backward-kill-word>" #'+backward-kill-whitespace-or-word) ; M-delete or C-backspace

  ;; Enable some useful Emacs commands by default
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)

  (defvar-keymap ematrix-open-thing-map
    :doc "Open/toggle thing, under `C-c o'."
    :name "Open/toggle thing")

  (keymap-global-set "C-c o" ematrix-open-thing-map)

  ;; Disable previously enabled custom themes before enabling a new one.
  (advice-add
   'load-theme :before
   (satch-defun +theme--disable-previous-themes:before-a (&rest _)
     "Disable previously enabled themes before enabling the new one."
     (mapc #'disable-theme custom-enabled-themes)))

  ;; Show trailing whitespace in `prog-mode' and `conf-mode'
  (+setq-hook! (prog-mode conf-mode) show-trailing-whitespace t)

  ;; By default, Emacs asks before quitting with "C-x C-c", but when running an
  ;; Emacs Client session, it won't ask unless a file is not saved. I hit "C-x
  ;; C-c" a lot by error, so lets make it ask before quitting.
  (advice-add
   'save-buffers-kill-terminal :around
   (satch-defun +emacs--ask-on-emacsclient:around-a (origfn arg)
     (if (frame-parameter nil 'client)
         (pcase (read-answer "Quit Emacs? " '(("yes"  ?y "quit Emacs Client")
                                              ("no"   ?n "don't quit")
                                              ("quit" ?q "kill Emacs")))
           ("yes" (apply origfn arg))
           ("quit" (kill-emacs)))
       (apply origfn arg))))

  ;; Guess the major mode after saving a file in `fundamental-mode' (adapted from Doom Emacs).
  (defun +save--guess-file-mode-h ()
    "Guess major mode when saving a file in `fundamental-mode'.
Likely, something has changed since the buffer was opened. e.g. A shebang line
or file path may exist now."
    (when (eq major-mode 'fundamental-mode)
      (let ((buffer (or (buffer-base-buffer) (current-buffer))))
        (and (buffer-file-name buffer)
             (eq buffer (window-buffer (selected-window))) ;; Only visible buffers
             (set-auto-mode)))))

  ;; Advice `emacs-session-filename' to ensure creating "session.ID" files in a sub-directory
  (let ((x-win-dir (+directory-ensure ematrix-local-dir "x-win/")))
    (advice-add
     'emacs-session-filename :filter-return
     (satch-defun +emacs-session-filename--in-subdir:filter-return-a (session-filename)
       "Put the SESSION-FILENAME in the \"x-win/\" sub-directory."
       (concat x-win-dir (file-name-nondirectory session-filename))))

    ;; Don't show session files in recentf list and so on
    (+ignore-root x-win-dir))

  ;; Offer to create parent directories if they do not exist
  ;; https://github.com/cjohansen/.emacs.d/blob/master/settings/sane-defaults.el
  (defun +create-non-existent-directory ()
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
        (make-directory parent-directory t))))

  (add-to-list 'find-file-not-found-functions #'+create-non-existent-directory))
#+end_src

**** package ~crm~
#+begin_src emacs-lisp
(use-package crm
  :config
  ;; From: github.com/a-schaefers/spartan-emacs/blob/main/spartan-layers/spartan-vertico.el
  ;; Add prompt indicator to `completing-read-multiple'. We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (advice-add
   #'completing-read-multiple :filter-args
   (satch-defun +crm--indicator:filter-args-a (args)
     (cons (format "[CRM%s] %s" (replace-regexp-in-string "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" "" crm-separator) (car args)) (cdr args)))))
#+end_src

**** package ~transient~
#+begin_src emacs-lisp
(use-package transient
  :straight (:source gnu-elpa-mirror)
  :autoload transient-define-prefix transient-define-infix transient-define-suffix
  :bind (:map
         transient-map ; Map ESC and q to quit transient
         ("q" . transient-quit-one)
         ("<escape>" . transient-quit-one)))
#+end_src

**** package ~which-key~
#+begin_src emacs-lisp
(use-package which-key
  :straight (:source gnu-elpa-mirror)
  :hook (ematrix-lazy . which-key-mode)
  :custom
  (which-key-idle-delay 1.0)
  (which-key-idle-secondary-delay nil)
  (which-key-ellipsis "..")
  (which-key-prefix-prefix "+")
  (which-key-sort-order #'which-key-key-order-alpha)
  (which-key-min-display-lines 3)
  (which-key-max-display-columns nil)
  (which-key-allow-multiple-replacements t) ; Allow multiple rules in `which-key-replacement-alist'
  :config
  ;; Setup `which-key' integration with the minibuffer
  (which-key-setup-minibuffer))
#+end_src

**** package ~tramp~
#+begin_src emacs-lisp
(use-package tramp
  :straight (:source gnu-elpa-mirror)
  :init
  ;; This is faster than the default "scp"
  (unless os/win
    (setq tramp-default-method "ssh"))
  :custom
  (tramp-auto-save-directory (concat ematrix-local-dir "tramp-auto-save/"))
  (tramp-backup-directory-alist backup-directory-alist)
  (tramp-default-remote-shell "/bin/bash"))
#+end_src

**** package ~password-cache~
#+begin_src emacs-lisp
(use-package password-cache
  :custom
  (password-cache t) ; Enable password caching
  (password-cache-expiry 60)) ; Cache for one minute (def. 16s)
#+end_src

**** pacakge ~auth-source~
#+begin_src emacs-lisp
(use-package auth-source
  :custom
  (auth-sources '("~/.authinfo.gpg")) ; Default auth-sources to GPG
  (auth-source-do-cache t) ; Enable caching, do not keep asking about GPG key
  (auth-source-cache-expiry 86400)) ; All day (def. 7200s = 2h)
#+end_src

**** package ~epa~
#+begin_src emacs-lisp
(use-package epa
  :custom
  (epg-pinentry-mode 'loopback)) ; Force gpg-agent to use minibuffer to prompt for passphrase (GPG 2.1+).
#+end_src

**** pacakge ~epa-file~
#+begin_src emacs-lisp
(use-package epa-file
  :after ematrix-first-file
  :demand
  :config
  (+shutup! (epa-file-enable)))
#+end_src

**** package ~dired~
#+begin_src emacs-lisp
(use-package dired
  ;; Enable adding mail attachments from dired "C-c RET C-a" for
  ;; `gnus-dired-attach'
  :hook (dired-mode . turn-on-gnus-dired-mode)
  :custom
  (dired-dwim-target t)
  (dired-auto-revert-buffer t)
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'top)
  (dired-clean-confirm-killing-deleted-buffers nil)
  :config
  ;; Open some files with OS' default application
  (when-let (cmd (cond ((or os/linux os/bsd) "xdg-open") (os/mac "open") (os/win "start")))
    (setq dired-guess-shell-alist-user
          `(("\\.\\(?:docx?\\|pdf\\|djvu\\|eps\\)\\'" ,cmd)
            ("\\.\\(?:jpe?g\\|png\\|gif\\|xpm\\|webp\\|svg\\)\\'" ,cmd)
            ("\\.\\(?:xcf\\)\\'" ,cmd)
            ("\\.\\(csv\\|xlsx?\\)\\'" ,cmd)
            ("\\.\\(tex\\|bib\\)\\'" ,cmd)
            ("\\.\\(?:mp4\\|mkv\\|avi\\|flv\\|rm\\|mpg\\|webm\\|rmvb\\|ogv\\)\\(?:\\.part\\)?\\'" ,cmd)
            ("\\.\\(?:mp3\\|flac\\|wav\\|ogg\\|m4a\\)\\'" ,cmd)
            ("\\.html?\\'" ,cmd)
            ("\\.md\\'" ,cmd)))))

(use-package dired-aux
  :custom
  (dired-vc-rename-file t)
  (dired-create-destination-dirs 'ask))

(use-package dired-x
  :hook (dired-mode . dired-omit-mode)
  :custom
  (dired-omit-verbose nil)
  :config
  (cl-callf concat dired-omit-files
    "\\|^\\.\\(?:svn\\|git\\|hg\\|repo\\)\\'"
    "\\|^\\.DS_Store\\'"
    "\\|^flycheck_.*"
    "\\|^\\.ccls-cache\\'"
    "\\|^\\.tags\\|\\.clink.db\\|GTAGS\\|GPATH\\|GRTAGS\\'"
    "\\|\\(?:\\.js\\)?\\.meta\\'"
    "\\|\\.\\(?:elc\\|o\\|pyo\\|swp\\|class\\)\\'"))
#+end_src

**** package ~doc-view~
#+begin_src emacs-lisp
(use-package doc-view
  :custom
  (doc-view-continuous t)
  (doc-view-mupdf-use-svg (+emacs-features-p 'rsvg)))
#+end_src

**** package ~project~
#+begin_src emacs-lisp
(use-package project
  :straight (:source gnu-elpa-mirror)
  :commands project-remember-projects-under
  :hook (kill-emacs . +project-forget-zombie-projects)
  :custom
  (project-vc-extra-root-markers
   '(".projectile.el" ".project.el" ".project" ; Emacs
     ".repo" ; Repo workspaces
     "autogen.sh" ; Autotools
     "*.csproj" "*.vbproj" "*.vcxproj" "*.vdproj" ".code-workspace" ; Visual Studio
     "requirements.txt" ; Python
     "package.json" ; Node.js
     "pom.xml" ; Apache Maven (Java/Kotlin)
     "client" "tools" "configs" ;future
     "Cargo.toml")) ; Cargo (Rust)
  :bind (("C-x p a" . +project-add-project))
  :config
  (add-to-list 'project-switch-commands '(project-shell "Shell") t))
#+end_src

**** [X] package ~tab-bar~
#+begin_src emacs-lisp :tangle no
(use-package tab-bar
  :hook (ematrix-lazy . tab-bar-mode)
  :custom
  (tab-bar-format '(tab-bar-format-history tab-bar-format-tabs tab-bar-separator))
  (tab-bar-tab-name-function #'+tab-bar-tab-name-by-project)
  (tab-bar-tab-name-format-function #'+tab-bar-tab-spaced-name-format)
  (tab-bar-close-button-show nil)
  (tab-bar-auto-width-max '(150 20))
  (tab-bar-tab-hints t)
  (tab-bar-show nil)
  :init
  (defcustom +tab-bar-tab-name-function-ignored-buffers '("\\*Bookmark List\\*")
    "Regexps matching buffers to be ignored."
    :type '(repeat regexp))
  :config
  (defun +tab-bar-tab-spaced-name-format (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (propertize
       (concat (if tab-bar-tab-hints (format " %c " (+ ?❶ (1- i))) "")
               (alist-get 'name tab)
               (or (and tab-bar-close-button-show
                        (not (eq tab-bar-close-button-show
                                 (if current-p 'non-selected 'selected)))
                        tab-bar-close-button)
                   ""))
       'face (funcall tab-bar-tab-face-function tab))))

  ;; Inspired by github.com/alphapapa/ap.el
  (defun +tab-bar-tab-name-by-project ()
    "Return project name or tab bar name."
    (cl-labels ((buffer-project (buffer)
                  (if-let ((file-name (buffer-file-name buffer)))
                      (project-current nil (file-name-directory file-name))
                    (project-current nil (buffer-local-value 'default-directory buffer))))
                (window-prev-buffers-last-project (windows)
                  (cl-loop for (buffer _ _) in windows
                           unless (cl-loop for regexp in +tab-bar-tab-name-function-ignored-buffers
                                           thereis (string-match-p regexp (buffer-name buffer)))
                           when (buffer-project buffer) return it)))
      (if-let ((project (or (buffer-project (window-buffer (minibuffer-selected-window)))
                            (window-prev-buffers-last-project (window-prev-buffers (minibuffer-selected-window))))))
          (concat (unless tab-bar-tab-hints " ") "π " (project-name project))
        (tab-bar-tab-name-current-with-count)))))
#+end_src

**** package ~flymake~
#+begin_src emacs-lisp
(use-package flymake
  :straight (:source gnu-elpa-mirror)
  :hook ((prog-mode conf-mode) . flymake-mode)
  :custom
  (flymake-fringe-indicator-position 'right-fringe)
  (flymake-error-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-error))
  (flymake-warning-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-warning))
  (flymake-note-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-info))
  :config
  (transient-define-prefix +flymake-transient ()
    "Transient for flymake."
    [[("n" "Next error" flymake-goto-next-error :transient t)
      ("N" "Prev error" flymake-goto-prev-error :transient t)]
     [("B" "Buffer diagnostics" flymake-show-buffer-diagnostics :transient t)
      ("P" "Project diagnostics" flymake-show-project-diagnostics :transient t)
      ("L" "Log buffer" flymake-switch-to-log-buffer :transient t)]
     [("S" "Start" flymake-start :transient t)
      ("Q" "Quit" ignore :transient t)]])

  ;; Use the session's `load-path' with flymake
  (with-eval-after-load 'elisp-mode
    (cl-callf append elisp-flymake-byte-compile-load-path load-path))

  ;; Larger right frings
  (with-eval-after-load 'fringe
    (set-fringe-style '(8 . 13)))

  ;; Better fringe bitmaps
  (define-fringe-bitmap '+flymake-bitmap-left-arrow-hi-res
    [#b00000011110
     #b00000111100
     #b00001111000
     #b00011110000
     #b00111100000
     #b01111000000
     #b01111000000
     #b00111100000
     #b00011110000
     #b00001111000
     #b00000111100
     #b00000011110]
    nil 13))
#+end_src

**** package ~xt-mouse~
#+begin_src emacs-lisp
(use-package xt-mouse
  :hook (tty-setup . xterm-mouse-mode))
#+end_src

**** package ~eshell~
#+begin_src emacs-lisp
(use-package eshell
  :custom
  (eshell-scroll-to-bottom-on-input 'this))
#+end_src

**** package ~reftex & bibtex~
#+begin_src emacs-lisp
(use-package reftex ;; Inspired by Doom Emacs
  :hook (reftex-toc-mode . reftex-toc-rescan)
  :custom
  ;; Get RefTeX working with BibLaTeX. See: tex.stackexchange.com/a/31992/43165
  (reftex-cite-format
   '((?a . "\\autocite[]{%l}")
     (?b . "\\blockcquote[]{%l}{}")
     (?c . "\\cite[]{%l}")
     (?f . "\\footcite[]{%l}")
     (?n . "\\nocite{%l}")
     (?p . "\\parencite[]{%l}")
     (?s . "\\smartcite[]{%l}")
     (?t . "\\textcite[]{%l}"))
   ;; This is needed when `reftex-cite-format' is set. See:
   ;; superuser.com/a/1386206
   (reftex-plug-into-AUCTeX t)
   (reftex-toc-split-windows-fraction 0.3)))

(use-package bibtex
  :hook (bibtex-mode . display-line-numbers-mode)
  :custom
  (bibtex-dialect 'biblatex)
  (bibtex-align-at-equal-sign t)
  (bibtex-text-indentation 20))
#+end_src

**** package ~treesit~
#+begin_src emacs-lisp
(use-package treesit
  :when (+emacs-features-p 'tree-sitter)
  :custom
  (treesit-font-lock-level 4))
#+end_src

**** package ~dockerfile-ts-mode~
#+begin_src emacs-lisp
(use-package dockerfile-ts-mode
  :when (+emacs-features-p 'tree-sitter)
  :mode "/Dockerfile\\'")
#+end_src

**** package ~cmake-ts-mode~
#+begin_src emacs-lisp
(use-package cmake-ts-mode
  :when (+emacs-features-p 'tree-sitter)
  :mode "CMakeLists\\.txt\\'"
  :mode "\\.cmake\\'")
#+end_src

*** me-vars.el
:properties:
:header-args: :tangle core/me-vars.el :noweb yes :mkdirp yes
:end:
**** header
#+begin_src emacs-lisp
;; me-vars.el --- Ematrix -*- lexical-binding: t; -*-
<<logo>>
;;; Commentary:
;;; Code:
#+end_src

**** groups
#+begin_src emacs-lisp
;;; Ematrix groups
(defgroup ematrix nil "Ematrix specific functionalities." :group 'emacs)
(defgroup ematrix-apps nil "Ematrix applications." :group 'ematrix)
(defgroup ematrix-binary nil "Ematrix binary files." :group 'ematrix)
(defgroup ematrix-buffer nil "Ematrix buffer stuff." :group 'ematrix)
(defgroup ematrix-completion nil "Completion related stuff." :group 'ematrix)
(defgroup ematrix-core nil "Ematrix core tweaks." :group 'ematrix)
(defgroup ematrix-edit nil "Ematrix editor tweaks." :group 'ematrix)
(defgroup ematrix-keybinding nil "Ematrix keybinding." :group 'ematrix)
(defgroup ematrix-org nil "Ematrix org-mode tweaks." :group 'ematrix)
(defgroup ematrix-prog nil "Ematrix programming stuff." :group 'ematrix)
(defgroup ematrix-project nil "Ematrix project stuff." :group 'ematrix)
(defgroup ematrix-ui nil "Ematrix UI tweaks." :group 'ematrix)
(defgroup ematrix-utils nil "Ematrix utility functions." :group 'ematrix)
(defgroup ematrix-blog nil "Ematrix blog stuff" :group 'ematrix)
#+end_src

**** directories
#+begin_src emacs-lisp
;;; Ematrix directories
(defconst ematrix-ignore-user-config
  (let* ((ignores (getenv "EMATRIX_IGNORE_USER_CONFIG"))
         (ignores (and ignores (downcase ignores))))
    (when ignores
      (if (string= ignores "all")
          '(early-config init-tweaks modules config local/early-config local/init-tweaks local/modules local/config)
        (mapcar #'intern (split-string ignores)))))
  "Ignore loading these user configuration files.
Accepted values are: early-config, init-tweaks, modules, config,
local/early-config, local/init-tweaks, local/modules and local/config.
This list is automatically constructed from the space-separated values in the
environment variable \"$EMATRIX_IGNORE_USER_CONFIG\".")

(defconst ematrix-debug-p
  (and (or (getenv "EMATRIX_DEBUG") init-file-debug) t)
  "Ematrix is started in debug mode.")

(defconst ematrix-verbose-p
  (and (or (getenv "EMATRIX_VERBOSE") ematrix-debug-p) t)
  "Ematrix is started in verbose mode.")

(defconst ematrix-always-demand-p
  (and (getenv "EMATRIX_ALWAYS_DEMAND") t)
  "Load all packages immediately, do not defer any package.")

(defconst ematrix-not-lazy-p
  (or ematrix-always-demand-p (daemonp) (and (getenv "EMATRIX_NOT_LAZY") t))
  "Load lazy packages (ematrix-lazy-hook) immediately.")

(defconst ematrix-load-all-modules-p
  (and (getenv "EMATRIX_LOAD_ALL_MODULES") t)
  "Force loading all Ematrix modules.")

(defconst ematrix-no-proxies-p
  (and (getenv "EMATRIX_NO_PROXIES") t)
  "Disable proxies in `ematrix-proxies'.")

(defcustom ematrix-msg-level
  (let ((level (string-to-number (or (getenv "EMATRIX_MSG_LEVEL") ""))))
    (cond (ematrix-verbose-p 4)
          ((> level 0) level)
          (t 1)))
  "Level of printed messages.
1 - `+error!'
2 - `+info!'
3 - `+log!'
4 - `+debug!'"
  :group 'ematrix-core
  :type '(choice
          (const :tag "Error" 1)
          (const :tag "Info" 2)
          (const :tag "Log" 3)
          (const :tag "Debug" 4)))

;; Derive the root directory from this file path
(defconst ematrix-root-dir (abbreviate-file-name (file-name-directory (directory-file-name (file-name-directory (file-truename load-file-name))))))
(defconst ematrix-core-dir (concat ematrix-root-dir "core/"))
(defconst ematrix-assets-dir (concat ematrix-root-dir "assets/"))
(defconst ematrix-elisp-dir (concat ematrix-root-dir "elisp/"))
(defconst ematrix-modules-dir (concat ematrix-root-dir "modules/"))
(defconst ematrix-obsolete-modules-dir (concat ematrix-modules-dir "obsolete/"))
(defconst ematrix-extras-dir (concat ematrix-modules-dir "extras/"))
(defconst ematrix-local-dir (concat ematrix-root-dir "local/"))
(defconst ematrix-cache-dir (concat ematrix-local-dir "cache/"))
(defconst ematrix-loaddefs-file (concat ematrix-core-dir "me-loaddefs.el"))
(defconst ematrix-extra-packages-dir (concat ematrix-local-dir "extra-packages/"))
(defconst ematrix-blog-dir (concat ematrix-root-dir "blog/"))
(defconst ematrix-config-dir (file-name-as-directory
                               (or (getenv "EMATRIX_DIR") (getenv "EMATRIXDIR")
                                   (if (file-directory-p "~/.ematrix.d/") "~/.ematrix.d/" (concat ematrix-root-dir "user-config/"))))
  "Ematrix user customization directory.")
#+end_src

**** system
#+begin_src emacs-lisp
;;System
(defconst ematrix-started-with-extra-args-p (and (cdr command-line-args) t) "Has Emacs been started with extras arguments? like a file name or so.")
(defconst os/linux (eq system-type 'gnu/linux) "Non-nil on GNU/Linux systems.")
(defconst os/bsd (and (memq system-type '(berkeley-unix gnu/kfreebsd)) t) "Non-nil on BSD systems.")
(defconst os/win (and (memq system-type '(cygwin windows-nt ms-dos)) t) "Non-nil on Windows systems.")
(defconst os/mac (eq system-type 'darwin) "Non-nil on MacOS systems.")

(defconst sys/arch (intern (car (split-string system-configuration "-")))
  "The system's architecture read from `system-configuration'.
It return a symbol like `x86_64', `aarch64', `armhf', ...")

(defconst emacs/features
  (mapcar #'intern
          (mapcar (apply-partially #'string-replace "_" "-")
                  (mapcar #'downcase (split-string system-configuration-features))))
  "List of symbols representing Emacs' enabled features.
Compiled from the `system-configuration-features'.")
#+end_src

**** keys
#+begin_src emacs-lisp
(defcustom ematrix-leader-key "SPC"
  "Ematrix leader key."
  :group 'ematrix-keybinding
  :type 'string)

(defcustom ematrix-localleader-key "SPC m"
  "Ematrix local leader (a.k.a. mode specific) key sequence."
  :group 'ematrix-keybinding
  :type 'string)

(defcustom ematrix-global-leader-prefix "C-SPC"
  "Ematrix general leader key."
  :group 'ematrix-keybinding
  :type 'string)

(defcustom ematrix-global-mode-prefix "C-SPC m"
  "Ematrix general local leader (a.k.a. mode specific) key sequence."
  :group 'ematrix-keybinding
  :type 'string)
#+end_src

**** misc
#+begin_src emacs-lisp
(defcustom ematrix-theme 'doom-one
  "The theme of Ematrix."
  :group 'ematrix-ui
  :type 'symbol)

(defcustom ematrix-disabled-packages nil
  "List of packages to be disabled when loading Ematrix modules.
This can be useful if you want to enable a module but you don't want a package
of being enabled."
  :group 'ematrix-core
  :type '(list symbol))

(defvar ematrix-configured-packages nil
  "List of packages installed and configured by Ematrix during startup.")

(defcustom ematrix-after-loading-modules-hook nil
  "This hook will be run after loading Ematrix modules.
It is used internally to remove the `+use-package--check-if-disabled:around-a'
advice we set on `use-package' in `me-bootstrap'."
  :group 'ematrix-core
  :type 'hook)

(defcustom ematrix-after-setup-fonts-hook nil
  "Runs after setting Ematrix fonts, runs at the end of `+setup-fonts'."
  :group 'ematrix-ui
  :type 'hook)

(defcustom ematrix-after-load-theme-hook nil
  "Runs after loading Ematrix theme, runs at the end of `+load-theme'."
  :group 'ematrix-ui
  :type 'hook)

(defcustom ematrix-after-startup-hook nil
  "This hook will be run after loading Emacs.

Ematrix hooks will be run in this order:
1. `ematrix-after-startup-hook'
2. `ematrix-lazy-hook'"
  :group 'ematrix-core
  :type 'hook)

(defcustom ematrix-lazy-hook nil
  "This hook will be run after loading Emacs, with laziness.

Ematrix hooks will be run in this order:
1. `ematrix-after-startup-hook'
2. `ematrix-lazy-hook'"
  :group 'ematrix-core
  :type 'hook)

(defcustom ematrix-proxies nil
  "Ematrix proxies.

Example, set it to:

\\='((\"no\" . \"localhost,127.0.0.1,.local,.mylocaltld\")
  (\"ftp\" . \"http://myproxy.local:8080/\")
  (\"http\" . \"http://myproxy.local:8080/\")
  (\"https\" . \"http://myproxy.local:8080/\")))

These will set the environment variables \"no_proxy\", \"ftp_proxy\", ...

When set in \"early-config.el\" or in \"init-tweaks.el\", Ematrix will enable
it automatically."
  :group 'ematrix-core
  :type '(repeat (cons string string)))

(defvaralias 'ematrix-build-functions-hook 'ematrix-build-functions)
(defvar ematrix-build-functions nil
  "Special hook for build functions that are run after completing package updates.")

(defcustom +env-file (concat ematrix-local-dir "system-env.el")
  "The file in which the environment variables will be saved."
  :group 'ematrix-core
  :type 'file)

;; Inspired by Doom Emacs
(defcustom +env-deny-vars
  '(;; Unix/shell state that shouldn't be persisted
    "^HOME$" "^\\(OLD\\)?PWD$" "^SHLVL$" "^PS1$" "^R?PROMPT$" "^TERM\\(CAP\\)?$"
    "^USER$" "^GIT_CONFIG" "^INSIDE_EMACS$" "^SESSION_MANAGER$" "^_$"
    "^JOURNAL_STREAM$" "^INVOCATION_ID$" "^MANAGERPID$" "^SYSTEMD_EXEC_PID$"
    "^DESKTOP_STARTUP_ID$" "^LS_?COLORS$" "^$"
    ;; Python virtual environment
    "^VIRTUAL_ENV$"
    ;; KDE session
    "^KDE_\\(FULL_SESSION\\|APPLICATIONS_.*\\|SESSION_\\(UID\\|VERSION\\)\\)$"
    ;; X server, Wayland, or services' env that shouldn't be persisted
    "^DISPLAY$" "^WAYLAND_DISPLAY" "^DBUS_SESSION_BUS_ADDRESS$" "^XAUTHORITY$"
    "^WINDOWID$" "^GIO_LAUNCHED_DESKTOP_FILE_PID$"
    ;; Windows+WSL envvars that shouldn't be persisted
    "^WSL_INTEROP$"
    ;; XDG variables that are best not persisted.
    "^XDG_CURRENT_DESKTOP$" "^XDG_RUNTIME_DIR$"
    "^XDG_\\(VTNR\\|SEAT\\|SESSION_\\(TYPE\\|CLASS\\|ID\\|PATH\\|DESKTOP\\)\\)"
    ;; Socket envvars, like I3SOCK, GREETD_SOCK, SEATD_SOCK, SWAYSOCK, etc.
    "SOCK$"
    ;; SSH and GPG variables that could quickly become stale if persisted.
    "^SSH_\\(AUTH_SOCK\\|AGENT_PID\\)$" "^\\(SSH\\|GPG\\)_TTY$" "^GPG_AGENT_INFO$"
    ;; Tmux session
    "^TMUX$"
    ;; Ematrix envvars
    "^EMATRIX_")
  "Environment variables to omit.
Each string is a regexp, matched against variable names to omit from
`+env-file' when saving evnironment variables in `+env-save'."
  :group 'ematrix-core
  :type '(repeat regexp))

;; Functions
(defun +load-user-configs (&rest configs)
  "Load user configurations CONFIGS."
  (dolist (conf configs)
    (unless (memq conf ematrix-ignore-user-config)
      (let ((conf-path (format "%s%s.el" ematrix-config-dir conf)))
        (when (file-exists-p conf-path) (+load conf-path))))))

(defun +load (&rest filename-parts)
  "Load a file, the FILENAME-PARTS are concatenated to form the file name."
  (let ((filename (file-truename (apply #'file-name-concat filename-parts))))
    (if (file-exists-p filename)
        (with-demoted-errors "[Ematrix:LoadError] %s"
          (load filename nil (not ematrix-verbose-p)))
      (message "[Ematrix:Error] Cannot load \"%s\", the file doesn't exists." filename))))


(provide 'me-vars)

;;; me-vars.el ends here
#+end_src

*** me-gc.el
:properties:
:header-args: :tangle core/me-gc.el :noweb yes :mkdirp yes
:end:
#+begin_src emacs-lisp
;; me-gc.el --- Ematrix -*- lexical-binding: t; -*-
<<logo>>
;;; Commentary:
;;; Code:
;; The `gc-cons-threshold' has been set in "early-init.el" to a ridiculously
;; high value (`most-positive-fixnum') to reduce the number of garbage
;; collections during startup, it will be overwritten by `gcmh-mode' or by the
;; following hook, so we place it at the end of `ematrix-lazy-hook' to maximize
;; the benefit.

;; NOTE: I'm experimenting with these settings instead of using `gcmh'.
;; See: https://zenodo.org/records/10213384
(when (+package-disabled-p 'gcmh)
  (add-hook
   'ematrix-lazy-hook
   (satch-defun +ematrix--gc-tweaks-h ()
     (setq gc-cons-threshold (* 128 1024 1024)
           gc-cons-percentage 0.25))
   90))

(use-package gcmh
  :straight t
  :init
  (add-hook 'ematrix-lazy-hook #'gcmh-mode 90)
  :custom
  ;; Set the delay to 20s instead of the default 15. I tried using `auto', but
  ;; with the default 20 of `gcmh-auto-idle-delay-factor', it triggers GC each
  ;; 1s on my machine. Setting the factor to a higher value should solve the
  ;; issue on my machine, but I don't think it is right to assume it will work
  ;; the same way on other machines. So we switch back to a fixed delay of 20s.
  (gcmh-idle-delay 20)
  ;; The default `gcmh's 1GB is probably too high. We set it to 256MB on 64bit
  ;; systems, or 16MB on 32bit ones.
  (gcmh-high-cons-threshold (* 1024 1024 (if (string-suffix-p "64" (symbol-name sys/arch)) 256 16))))

(provide 'me-gc)
;;; me-gc.el ends here
#+end_src

*** me-lib.el
:properties:
:header-args: :tangle core/me-lib.el :noweb yes :mkdirp yes
:end:
#+begin_src emacs-lisp
;; me-lib.el --- Ematrix -*- lexical-binding: t; -*-
<<logo>>
;;; Commentary:
;;; Code:
(require 'me-vars)

(autoload 'cl-loop "cl-macs" nil nil 'macro)
(autoload 'url-filename "url-parse")
(autoload 'url-generic-parse-url "url-parse")
(autoload 'vc-git-root "vc-git")
(autoload 'vc-git-revert "vc-git")
(autoload 'tramp-make-tramp-file-name "tramp")
(defvar tramp-root-id-string) ; Make byte-compiler happy

(require 'rx)



(defvar ematrix--lazy-low-priority-forms nil)
(defvar ematrix--lazy-high-priority-forms nil)

(defmacro +with-delayed! (&rest body)
  "Delay evaluating BODY with priority 0 (high priority)."
  (declare (indent 0))
  `(push ',(macroexp-progn body) ematrix--lazy-high-priority-forms))

(defmacro +with-delayed-1! (&rest body)
  "Delay evaluating BODY with priority 1."
  (declare (indent 0))
  `(push ',(macroexp-progn body) ematrix--lazy-low-priority-forms))



;;; Some plist and alist missing functions

(defun +varplist-get (vplist keyword &optional car-p)
  "Get KEYWORD's value from variable value length VPLIST.
Ex: (+varplist-get \\='(:a \\='a :b \\='b1 \\='b2) :b) -> \\='(b1 b2)."
  (funcall
   (if car-p #'cadr #'cdr)
   (cl-loop for element in (memq keyword vplist)
            until (and (not (eq element keyword)) (keywordp element))
            collect element)))

(defun +plist-keys (plist)
  "Return the keys of PLIST."
  (let (keys)
    (while plist
      (push (car plist) keys)
      (setq plist (cddr plist)))
    keys))

(defmacro +plist-push! (plist &rest key-vals)
  "Push KEY-VALS to PLIST."
  (declare (indent 1))
  (let ((out (list 'progn)))
    (while (length> key-vals 0)
      (let ((key (pop key-vals))
            (val (pop key-vals)))
        (cl-callf append out `((setq ,plist (plist-put ,plist ,key ,val))))))
    out))

(defun +plist-combine (&rest plists)
  "Create a single property list from all plists in PLISTS.
Modified from `org-combine-plists'. This supposes the values to be vectors,
and concatenate them."
  (let ((res (copy-sequence (pop plists)))
        prop val plist)
    (while plists
      (setq plist (pop plists))
      (while plist
        (setq prop (pop plist) val (pop plist))
        (setq res (plist-put res prop (vconcat val (plist-get res prop))))))
    res))

(defun +plist-delete (plist prop)
  "Delete property PROP from PLIST.
Adapted from `org-plist-delete'."
  (let (p)
    (while plist
      (if (not (eq prop (car plist)))
          (setq p (plist-put p (car plist) (nth 1 plist))))
      (setq plist (cddr plist)))
    p))

(defun +plist-to-alist (plist &optional trim-col)
  "Convert PLIST to an alist, trim first colon when TRIM-COL."
  (let (res)
    (while plist
      (let* ((key (pop plist))
             (val (pop plist))
             (key (if (and trim-col (string-prefix-p ":" (symbol-name key)))
                      (intern (substring (symbol-name key) 1))
                    key)))
        (push (cons key val) res)))
    (nreverse res)))

(defun +alist-to-plist (alist &optional add-col)
  "Convert ALIST to a plist, add colon to the keys when ADD-COL."
  (let (res)
    (dolist (x alist)
      (let ((key (car x)))
        (cl-assert (or (and (not nil) (atom key)) (stringp key)) t "The alist should have keys that are symbols or strings")
        (push (if add-col (intern (format ":%s" key)) key) res)
        (push (cdr x) res)))
    (nreverse res)))

;; Taken from: emacs.stackexchange.com/q/33892/12534
(defun +alist-set (key val alist &optional symbol)
  "Set property KEY to VAL in ALIST. Return new alist.
This creates the association if it is missing, and otherwise sets the cdr of the
first matching association in the list. It does not create duplicate
associations. By default, key comparison is done with `equal'. However, if
SYMBOL is non-nil, then `eq' is used instead.

This method may mutate the original alist, but you still need to use the return
value of this method instead of the original alist, to ensure correct results."
  (if-let* ((pair (if symbol (assq key alist) (assoc key alist))))
      (setcdr pair val)
    (push (cons key val) alist))
  alist)

(defmacro +mode-alist-add-ts-modes! (mode-alist)
  "Duplicate elements in MODE-ALIST to include Treesit modes.

For the alist \=((some-mode . spec)), this will add \=(some-ts-mode . spec)."
  `(cl-callf append ,mode-alist
    (cl-loop
     for mode-spec in ,mode-alist
     collect (let ((ts-mode (intern (format "%s-ts-mode" (string-remove-suffix "-mode" (symbol-name (car mode-spec)))))))
              (when (fboundp ts-mode) (cons ts-mode (cdr mode-spec)))))))

;;; Missing primitive utilities

(defun +set-standard-value (variable value)
  "Set the standard value of VARIABLE to VALUE."
  (put variable 'standard-value `((funcall (function ,(lambda nil "" value))))))

(defun +standard-value (variable)
  "Return the standard value for VARIABLE."
  (eval (car (get variable 'standard-value)) t))

(defun +reset-standard-value (variable)
  "Reset VARIABLE to its standard value."
  (set variable (+standard-value variable)))

;; Adapted from `evil-unquote', takes functions into account
(defun +unquote (expr)
  "Return EXPR unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe expr) '(quote function))
    (setq expr (cadr expr)))
  expr)

(defun +quoted-p (expr)
  "Return t when EXPR is quoted."
  (memq (car-safe expr) '(quote function)))

(defun +apply-partially-right (fun &rest args)
  "Like `apply-partially', but apply the ARGS to the right of FUN."
  (lambda (&rest args2)
    (apply fun (append args2 args))))



;;; Ematrix' core functions and macros

(defmacro +error! (msg &rest vars)
  "Log error MSG and VARS using `message'."
  (when (>= ematrix-msg-level 1)
    `(apply #'message (list (concat "[Ematrix:Error] " ,msg) ,@vars))))

(defmacro +info! (msg &rest vars)
  "Log info MSG and VARS using `message'."
  (when (>= ematrix-msg-level 2)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[Ematrix:Info] " ,msg) ,@vars)))))

(defmacro +log! (msg &rest vars)
  "Log MSG and VARS using `message' when `ematrix-verbose-p' is non-nil."
  (when (>= ematrix-msg-level 3)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[Ematrix:Log] " ,msg) ,@vars)))))

(defmacro +debug! (msg &rest vars)
  "Log debug MSG and VARS using `message' when `ematrix-msg-level' is 4."
  (when (>= ematrix-msg-level 4)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[Ematrix:Debug] " ,msg) ,@vars)))))

(defun +emacs-features-p (&rest feats)
  "Is features FEATS are enabled in this Emacs build."
  (and (cl-every (lambda (feat) (memq feat emacs/features)) feats) t))

(defmacro +fn-inhibit-messages! (fn &optional no-message-log)
  "Add an advice around the function FN to suppress messages in echo area.
If NO-MESSAGE-LOG is non-nil, do not print any message to *Messages* buffer."
  (let ((advice-fn (make-symbol (format "+%s--inhibit-messages:around-a" fn))))
    `(advice-add
      ',fn :around
      (satch-defun ,advice-fn (origfn &rest args)
       (let ((message-log-max (unless ,no-message-log message-log-max)))
        (with-temp-message (or (current-message) "")
         (+debug! "Inhibiting messages of %s" ,(symbol-name fn))
         (apply origfn args)))))))

(defmacro +shutup! (&rest body)
  "Suppress new messages temporarily while evaluating BODY.
This inhebits both the echo area and the `*Messages*' buffer."
  (if (not ematrix-verbose-p)
      `(let ((message-log-max nil))
        (with-temp-message (or (current-message) "") ,@body))
    `(progn ,@body)))

(defmacro +cmdfy! (&rest body)
  "Convert BODY to an interactive command."
  `(lambda () (interactive) ,@body))

(defun +load-theme ()
  "Load Emacs' theme from `ematrix-theme'."
  (interactive)
  (when ematrix-theme
    (+log! "Loading user theme: %s" ematrix-theme)
    ;; Fallback to built-in `tsdh-light' when `ematrix-theme' is not available.
    (unless (ignore-errors (load-theme ematrix-theme t))
      (let ((default-theme (+standard-value 'ematrix-theme)))
        (+error! "Cannot load theme %S, trying to load the default theme %S" ematrix-theme default-theme)
        (unless (ignore-errors (load-theme default-theme t))
          (+error! "Cannot load default theme %S, falling back to the builtin tsdh-light theme" default-theme)
          (load-theme 'tsdh-light t)))))
  ;; Run hooks
  (run-hooks 'ematrix-after-load-theme-hook))

;; An internal variable to keep track of the tasks
(defvar +eval-when-idle--task-num 0)
(defcustom +eval-when-idle-delay 5.0
  "The default delay (in seconds) to consider in `+eval-when-idle!' macro."
  :group 'ematrix-core
  :type 'float)

(defcustom +lazy-delay 1.0
  "The default delay (in seconds) to consider in `+lazy!' macro."
  :group 'ematrix-core
  :type 'float)

(defun +eval-when-idle (delay &rest fns)
  "Queue FNS to be processed when Emacs becomes idle after DELAY seconds."
  (let* ((task-num (cl-incf +eval-when-idle--task-num))
         (task-name (make-symbol (format "+eval-when-idle--task-%d" task-num))))
    (with-memoization (get task-name 'timer)
      (run-with-idle-timer
       delay t
       (lambda ()
         (when-let* ((fn (pop fns)))
           (+log! "Running task %d, calling function `%s'" task-num (truncate-string-to-width (format "%s" fn) 40 nil nil "…"))
           (funcall fn))
         (unless fns
           (cancel-timer (get task-name 'timer))
           (put task-name 'timer nil)))))))

(defmacro +eval-when-idle! (&rest body)
  "Evaluate BODY when Emacs becomes idle."
  (declare (indent 0))
  `(+eval-when-idle ,+eval-when-idle-delay (lambda () ,@body)))

(defmacro +eval-when-idle-for! (delay &rest body)
  "Evaluate BODY after DELAY seconds from Emacs becoming idle."
  (declare (indent 1))
  `(+eval-when-idle ,delay (lambda () ,@body)))

(defmacro +deferred! (&rest body)
  "Run BODY after Emacs gets loaded, a.k.a. after `ematrix-loaded'."
  `(with-eval-after-load 'ematrix-loaded ,@body))

(defmacro +lazy! (&rest body)
  "Run BODY as a lazy block (see `ematrix-lazy')."
  `(with-eval-after-load 'ematrix-lazy
    (+eval-when-idle-for! +lazy-delay ,@body)))

(defmacro +after-load! (features &rest body)
  "Execute BODY after FEATURES have been loaded."
  (declare (indent 1))
  (let ((features (if (+quoted-p features) (+unquote features) (eval features))))
    (if (symbolp features)
        `(with-eval-after-load ',features ,@body)
      (let ((feature (car features)))
        (cond
         ((memq feature '(:or :any))
          (macroexp-progn
           (cl-loop for next in (cdr features)
                    collect `(with-eval-after-load ',(+unquote next) ,@body))))
         ((memq feature '(:and :all))
          (dolist (next (reverse (cdr features)) (car body))
            (setq body `((with-eval-after-load ',(+unquote next) ,@body)))))
         (t `(+after-load! '(:all ,@features) ,@body)))))))

(defvar +hook-once-num 0)

(defmacro +hook-once! (hook &rest body)
  "Hook BODY in HOOK, and make it run only once."
  (declare (indent 1))
  (let ((hook (+unquote hook))
        (fn-name (intern (format "+hook-once--function-%d-h" (cl-incf +hook-once-num)))))
    `(add-hook ',hook
      (satch-defun ,fn-name (&rest _)
       ,(macroexp-progn body)
       (remove-hook ',hook ',fn-name)))))

(defvar +advice-once-num 0)

(defmacro +advice-once! (fns how &rest body)
  "Run BODY as a HOW advice for FNS, and make it run only once.

FNS can be one function or a list of functions, quoted or not.

Inside BODY, you will have access to the original args as `orig-args'."
  (declare (indent 2))
  (let* ((fns (ensure-list (+unquote fns)))
         (fn-name (intern (format "+advice-once--function-%d-h" (cl-incf +advice-once-num))))
         (external-forms)
         (internal-forms))
    (dolist (fn fns)
      (push `(advice-add ',fn ,how ',fn-name) external-forms)
      (push `(advice-remove ',fn ',fn-name) internal-forms))
    (macroexp-progn
     (append
      (list (append `(defun ,fn-name (&rest orig-args))
                    internal-forms body))
      external-forms))))

(defcustom +first-file-hook-ignore-list nil
  "A list of files to ignore in the `ematrix-first-*-file-hook'."
  :group 'ematrix-core
  :type '(repeat file))

(defmacro +make-first-file-hook! (filetype ext-regexp)
  "Make a hook which run on the first FILETYPE file of a particular extensions.
The extension should matches EXT-REGEXP.

This will creates a function named `+first-file--FILETYPE-h' which gets executed
before `after-find-file'. This function will run on the first file that matches
EXT-REGEXP. When it runs, this function provides a feature named
`ematrix-first-FILETYPE-file' and a run all hooks in
`ematrix-first-FILETYPE-file-hook'."
  (let* ((filetype (+unquote filetype))
         (fn-name (intern (format "+first-%s-file:after-a" (if filetype (format "-%s" filetype) ""))))
         (hook-name (intern (format "ematrix-first%s-file-hook" (if filetype (format "-%s" filetype) ""))))
         (feature-name (intern (format "ematrix-first%s-file" (if filetype (format "-%s" filetype) ""))))
         (hook-docs (format "This hook will be run before opening the first %s file.

Applies to files that matches %S.

Executed before `find-file-noselect', it runs all hooks in `%s' and provide the `%s' feature."
                            (or filetype "") (eval ext-regexp) hook-name feature-name)))
    `(progn
       (+log! "Setting up hook `%s' -- function `%s' -- feature `%s'." ',hook-name ',fn-name ',feature-name)
       (defcustom ,hook-name nil ,hook-docs :group 'ematrix-core :type 'hook)
       (defun ,fn-name (&optional filename &rest _)
        (when (and
               after-init-time ; after Emacs initialization
               filename ; for named files
               (or
                (featurep 'ematrix-loaded) ; after Ematrix is loaded
                (when-let* ((files (cdr command-line-args))) ; or immediately if the file is passed as a command line argument
                 (cl-some (lambda (file) (string= (expand-file-name filename) (expand-file-name file))) files)))
               (not ; not an ignored file
                (member (expand-file-name filename) (mapcar #'expand-file-name +first-file-hook-ignore-list)))
               (let ((case-fold-search t)) ; file name matches the regexp (case-insensitive)
                (string-match-p ,ext-regexp filename)))
         (+log! "Running %d `%s' hooks (triggered by: %s)." (length ,hook-name) ',hook-name filename)
         (advice-remove 'find-file-noselect #',fn-name)
         (provide ',feature-name)
         (run-hooks ',hook-name)))
       (if (daemonp) ; load immediately after init when in daemon mode
           (add-hook 'after-init-hook (lambda () (provide ',feature-name) (run-hooks ',hook-name)) 90)
         (advice-add 'find-file-noselect :before #',fn-name '((depth . ,(if filetype -90 -91))))))))

;; From Doom Emacs
(defun +resolve-hook-forms (hooks)
  "Convert a list of modes into a list of hook symbols.

If a mode is quoted, it is left as is. If the entire HOOKS list is quoted, the
list is returned as-is."
  (declare (pure t) (side-effect-free t))
  (let ((hook-list (ensure-list (+unquote hooks))))
    (if (eq (car-safe hooks) 'quote)
        hook-list
      (cl-loop for hook in hook-list
               if (eq (car-safe hook) 'quote)
               collect (cadr hook)
               else collect (intern (format "%s-hook" (symbol-name hook)))))))

(defun +setq-hook-fns (hooks rest &optional singles advice-how)
  (unless (or singles (= 0 (% (length rest) 2)))
    (signal 'wrong-number-of-arguments (list #'evenp (length rest))))
  (cl-loop with vars = (let ((args rest)
                             vars)
                         (while args
                           (push (if singles
                                     (list (pop args))
                                   (cons (pop args) (pop args)))
                                 vars))
                         (nreverse vars))
           for hook-or-func in (if advice-how (ensure-list (+unquote hooks)) (+resolve-hook-forms hooks))
           append
           (cl-loop for (var . val) in vars
                    collect
                    (list var val hook-or-func
                          (intern
                           (format "+setq--%s%s-%s-%s"
                                   var (if advice-how advice-how "-in")
                                   hook-or-func (if advice-how "a" "h")))))))

;; From Doom Emacs
(defmacro +add-hook! (hooks &rest rest)
  "A convenience macro for adding N functions to M hooks.

This macro accepts, in order:

  1. The mode(s) or hook(s) to add to. This is either an unquoted mode, an
     unquoted list of modes, a quoted hook variable or a quoted list of hook
     variables.
  2. Optional properties :local, :append, and/or :depth [N], which will make the
     hook buffer-local or append to the list of hooks (respectively),
  3. The function(s) to be added: this can be a quoted function, a quoted list
     thereof, a list of `defun' or `cl-defun' forms, or arbitrary forms (will
     implicitly be wrapped in a lambda).

If the hook function should receive an argument (like in
`enable-theme-functions'), the `args' variable can be expanded in the forms

  (+add-hook! \\='enable-theme-functions
    (message \"Enabled theme: %s\" (car args)))

\(fn HOOKS [:append :local [:depth N]] FUNCTIONS-OR-FORMS...)"
  (declare (indent (lambda (indent-point state)
                     (goto-char indent-point)
                     (when (looking-at-p "\\s-*(")
                       (lisp-indent-defform state indent-point))))
           (debug t))
  (let* ((hook-forms (+resolve-hook-forms hooks))
         (func-forms ())
         (defn-forms ())
         append-p local-p remove-p depth)
    (while (keywordp (car rest))
      (pcase (pop rest)
        (:append (setq append-p t))
        (:depth  (setq depth (pop rest)))
        (:local  (setq local-p t))
        (:remove (setq remove-p t))))
    (while rest
      (let* ((next (pop rest))
             (first (car-safe next)))
        (push (cond ((memq first '(function nil))
                     next)
                    ((eq first 'quote)
                     (let ((quoted (cadr next)))
                       (if (atom quoted)
                           next
                         (when (cdr quoted)
                           (setq rest (cons (list first (cdr quoted)) rest)))
                         (list first (car quoted)))))
                    ((memq first '(defun cl-defun))
                     (push next defn-forms)
                     (list 'function (cadr next)))
                    ((prog1 `(lambda (&rest args) ,@(cons next rest))
                       (setq rest nil))))
              func-forms)))
    `(progn
       ,@defn-forms
       (dolist (hook (nreverse ',hook-forms))
        (dolist (func (list ,@func-forms))
         ,(if remove-p
              `(remove-hook hook func ,local-p)
            `(add-hook hook func ,(or depth append-p) ,local-p)))))))

;; From Doom Emacs
(defmacro +remove-hook! (hooks &rest rest)
  "A convenience macro for removing N functions from M hooks.

Takes the same arguments as `add-hook!'.

If N = 1 and M = 1, there's no benefit to using this macro over `remove-hook'.

\(fn HOOKS [:append :local] FUNCTIONS)"
  (declare (indent defun) (debug t))
  `(+add-hook! ,hooks :remove ,@rest))

;; From Doom Emacs
(defmacro +setq-hook! (hooks &rest var-vals)
  "Set buffer-local variables on HOOKS.

HOOKS can be expect receiving arguments (like in `enable-theme-functions'), the
`args' variable can be used inside VAR-VALS forms to get the arguments passed
the the function.

  (+setq-hook! \\='enable-theme-functions
    current-theme (car args))

\(fn HOOKS &rest [SYM VAL]...)"
  (declare (indent 1))
  (macroexp-progn
   (cl-loop for (var val hook hook-fn) in (+setq-hook-fns hooks var-vals)
            collect `(defun ,hook-fn (&rest args)
                      ,(format "%s = %s" var (pp-to-string val))
                      (setq-local ,var ,val))
            collect `(add-hook ',hook #',hook-fn -90))))

(defmacro +setq-advice! (funcs how &rest var-vals)
  "Set buffer-local variables as HOW advices for FUNCS.

FUNCS can be expect receiving arguments, the `args' variable can
be used inside VAR-VALS forms to get the arguments passed the the
function.

  (+setq-advice! #'revert-buffer :before
    revert-buffer-function #'ignore)

\(fn FUNCS HOW &rest [SYM VAL]...)"
  (declare (indent 2))
  (macroexp-progn
   (cl-loop for (var val func advice-fn) in (+setq-hook-fns funcs var-vals nil how)
            collect `(defun ,advice-fn (&rest args)
                      ,(format "%s = %s" var (pp-to-string val))
                      (setq-local ,var ,val))
            collect `(advice-add #',func ,how #',advice-fn))))

;; From Doom Emacs
(defmacro +unsetq-hook! (hooks &rest vars)
  "Unbind setq hooks on HOOKS for VARS.

\(fn HOOKS &rest VAR1 VAR2...)"
  (declare (indent 1))
  (macroexp-progn
   (cl-loop for (_var _val hook fn)
            in (+setq-hook-fns hooks vars 'singles)
            collect `(remove-hook ',hook #',fn))))

;; Adapted from: Doom Emacs
(defun +compile-functions (&rest fns)
  "Queue FNS to be byte/natively-compiled after a brief delay."
  (dolist (fn fns)
    (+eval-when-idle!
      (if (featurep 'native-compile)
          (unless (subr-native-elisp-p (indirect-function fn))
            (cl-letf (((symbol-function 'comp-log-to-buffer) #'ignore)) ; do not log to `comp-log-buffer-name'
              (+shutup! (ignore-errors (native-compile fn)))))
        (unless (byte-code-function-p fn)
          (let (byte-compile-warnings)
            (+shutup! (byte-compile fn))))))))

(defvar +shell-command-switch
  (pcase shell-file-name
    ((rx bol "fish" eol) "-lc")
    ((rx bol (or "tsch" "csh") eol) "-dc")
    (_ "-ilc")))

;; Inspired by: emacs.stackexchange.com/a/21432/37002
(defun +shell-command-to-string-ignore-stderr (command)
  "Execute shell command COMMAND and return its output as a string.

Works like `shell-command-to-string' with three differences:
1. It uses `+shell-command-switch' instead of `shell-command-switch'.
2. It returns only stdout and ignore the output of stderr.
3. It sets TERM to \"smart\" instead of \"dumb\", to be able to escape from
Emacs-specific early exit in \".bashrc\"."
  (with-output-to-string
    (with-current-buffer standard-output
      ;; Do not pretend to be dumb (a.k.a. don't exit early when loading .bashrc)
      (let ((process-environment (append (list "TERM=smart") (remove "TERM=dumb" process-environment))))
        (process-file shell-file-name nil '(t nil) nil +shell-command-switch command)))))

(defun +env-save ()
  "Load environment variables from shell and save them to `+env-file'."
  (interactive)
  (unless os/win
    (with-temp-buffer
      (insert ";; -*- mode: emacs-lisp; no-byte-compile: t; no-native-compile: t; -*-\n\n")
      (let ((env-vars
             (mapcar ; Get environment variables from shell into an alist
              (lambda (line) (let ((var-val (string-split line "="))) (cons (car var-val) (string-join (cdr var-val) "="))))
              ;; "env --null" ends lines with null byte instead of newline
              (string-split (+shell-command-to-string-ignore-stderr "env --null") "\0"))))
        ;; Special treatment for the "PATH" variable, save it to `exec-path'
        (when-let* ((path (alist-get "PATH" env-vars nil nil #'string=)))
          (insert "\n;; Adding PATH content to `exec-path'\n"
                  (format "(setq exec-path (delete-dups (append exec-path '%s)))\n\n"
                          (mapcar (apply-partially #'format "\"%s\"") (parse-colon-path path)))))
        ;; Save the environment variables to `process-environment' using `setenv'
        (insert ";; Adding the rest of the environment variables\n")
        (dolist (env-var env-vars)
          (unless (cl-some (+apply-partially-right #'string-match-p (car env-var)) +env-deny-vars)
            (let ((value (cdr env-var)))
              ;; Correctly handle special characters
              (dolist (pair '(("\a" . "\\a") ("\b" . "\\b") ("\f" . "\\f")
                              ("\n" . "\\n") ("\r" . "\\r") ("\t" . "\\t")
                              ("\v" . "\\v") ("\"" . "\\\"")))
                (setq value (string-replace (car pair) (cdr pair) value)))
              (insert (format "(setenv \"%s\" \"%s\")\n" (car env-var) value))))))
      (write-file +env-file))))

(defun +env-load ()
  "Load environment variables from `+env-file'."
  (interactive)
  (unless os/win
    (unless (file-exists-p +env-file) (+env-save))
    (+load +env-file)))

(defun +ignore-root (&rest roots)
  "Add ROOTS to ignored projects, recentf, etc."
  (dolist (root roots)
    (with-eval-after-load 'recentf
      (add-to-list 'recentf-exclude (rx-to-string `(or ,root ,(expand-file-name root)))))))

(defun +package-disabled-p (package &optional module)
  "Is package PACKAGE disabled in `ematrix-disabled-packages'.

Optionally, check also for the containing MODULE."
  (or
   (and (memq package (apply #'append (mapcar #'ensure-list ematrix-disabled-packages))) t)
   (and module (not (memq module (append (bound-and-true-p ematrix-core-modules) ematrix-modules))))))

(defun ematrix-modules (&optional include-obsolete)
  "List all the available modules, with optional INCLUDE-OBSOLETE."
  (let ((mod-files (directory-files ematrix-modules-dir nil "\\`me-.*\\.el\\'")))
    (when include-obsolete
      (cl-callf append mod-files (mapcar (apply-partially #'concat "obsolete/")
                                         (directory-files ematrix-obsolete-modules-dir nil "\\`me-.*\\.el\\'"))))
    (mapcar #'intern (mapcar #'file-name-sans-extension mod-files))))



;;; Files, directories and IO helper functions

(defun +file-read-to-string (filename)
  "Return a string with the contents of FILENAME."
  (when (and (file-exists-p filename) (not (file-directory-p filename)))
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string))))

(defun +directory-subdirs (dir)
  "Return a list of sub-directories in DIR."
  (when dir
    (seq-filter #'file-directory-p (mapcar #'abbreviate-file-name (directory-files dir t "[^.][^.]?\\'")))))

(defun +directory-ensure (&rest path-parts)
  "Concatenate PATH-PARTS to construct a path and return it.

Ensure the path exists, if not create it. The exact behavior is to create the
parent directory if the path is a file, and if the path is a directory, create
that directory."
  (let* ((path (apply #'concat path-parts))
         (parent-dir (file-name-directory path)))
    (unless (file-directory-p parent-dir)
      (ignore-errors (mkdir parent-dir t))
      (unless (file-directory-p parent-dir)
        (+error! "Cannot create directory %s" parent-dir)))
    path))

(if (fboundp 'rename-visited-file)
    (defalias '+move-this-file #'rename-visited-file)
  (defun +move-this-file (new-path &optional force-p)
    "Move current buffer's file to NEW-PATH.

If FORCE-P, overwrite the destination file if it exists, without confirmation."
    (interactive
     (list (read-file-name "Move file to: ")
           current-prefix-arg))
    (unless (and buffer-file-name (file-exists-p buffer-file-name))
      (user-error "Buffer is not visiting any file"))
    (let ((old-path (buffer-file-name (buffer-base-buffer)))
          (new-path (expand-file-name new-path)))
      (when (directory-name-p new-path)
        (setq new-path (expand-file-name (file-name-nondirectory old-path) new-path)))
      (make-directory (file-name-directory new-path) t)
      (rename-file old-path new-path (or force-p 1))
      (set-visited-file-name new-path t t)
      (message "File moved to %S" (abbreviate-file-name new-path)))))



;;; Lock files

(defun +lock--file (name)
  "Get the absolute path of the lockfile for resource NAME."
  (expand-file-name (format "ematrix-%s.lock" name) temporary-file-directory))

(defun +lock--locker-pid (name)
  "Get thecker PID of resource NAME."
  (let ((fname (+lock--file name)))
    (and (file-exists-p fname) (string-to-number (+file-read-to-string fname)))))

(defun +lockedp (name)
  "Return non-nil if the resource NAME is locked."
  (when-let* ((pid (+lock--locker-pid name)))
    (and (process-attributes pid) t)))

(defun +locked-by-this-process-p (name)
  "Return non-nil if the resource NAME locked by this Emacs instance."
  (and (+lockedp name) (equal (emacs-pid) (+lock--locker-pid name))))

(defun +lock (name)
  "Lock the resource named NAME."
  (if (+lockedp name)
      (progn (+info! "Resource `%s' already locked!" name) nil)
    (+info! "Created lock file for resource `%s'!" name)
    (+shutup!
     (with-temp-buffer
       (insert (format "%d" (emacs-pid)))
       (write-file (+lock--file name))))
    t))

(defun +unlock (name &optional force-p)
  "Unlock the resource named NAME if locked by this process.
If FORCE-P is non-nil, force unlocking even if the resource is not locked by the
current process."
  (when (or force-p (+locked-by-this-process-p name))
    (+info! "Resource `%s' unlocked" name)
    (delete-file (+lock--file name))
    t))



;;; Misc Emacs tweaks

(defmacro +def-dedicated-tab! (cmd &rest body)
  "Define +CMD command to run BODY in a dedicated tab.
If not specified, BODY defaults to `(CMD)'.

You can pass an exit hook or exit function on which, the created workspace will
be deleted.

\(fn NAME [[:exit-hook HOOK] [:exit-func FUNC]] FORMS...)"
  (let* ((cmd (+unquote cmd))
         (fn-name (intern (format "+%s" cmd)))
         (fn-doc (format "Launch %s in a dedicated workspace." cmd))
         (tab-name (intern (format "+%s-tab-name" cmd)))
         (exit-fn-name (intern (format "+%s--close-workspace" cmd)))
         exit-func exit-hook sexp fn-body)
    (while (keywordp (car body))
      (pcase (pop body)
        (:exit-func (setq exit-func (+unquote (pop body))))
        (:exit-hook (setq exit-hook (+unquote (pop body))))))
    (setq sexp (if (null body) `((,cmd)) body))
    (when (or exit-func exit-hook)
      (setq
       fn-body
       `((defun ,exit-fn-name (&rest _)
          (if (fboundp 'tabspaces-mode)
              ;; When `tabspaces' is available, use it.
              (when-let* ((tab-num (seq-position (tabspaces--list-tabspaces) ,tab-name #'string=)))
               (tabspaces-close-workspace (1+ tab-num)))
            ;; Or default to the built-in `tab-bar'.
            (when-let* ((tab-num (seq-position (tab-bar-tabs) ,tab-name (lambda (tab name) (string= name (alist-get 'name tab))))))
             (tab-close (1+ tab-num)))))))
      (when exit-func
        (setq fn-body (append fn-body `((advice-add ',exit-func :after #',exit-fn-name)))))
      (when exit-hook
        (setq fn-body (append fn-body `((add-hook ',exit-hook #',exit-fn-name))))))
    `(progn
       (defvar ,tab-name ,(format "*%s*" cmd))
       (defun ,fn-name ()
        ,fn-doc
        (interactive)
        (when ,tab-name
         (if (fboundp 'tabspaces-mode)
             (tabspaces-switch-or-create-workspace ,tab-name)
           (tab-new)
           (tab-rename ,tab-name)))
        ,@sexp)
       ,(macroexp-progn fn-body)
       #',fn-name)))



;;; Eglot extras

;; Modified from Crafted Emacs, pass `eglot-server-programs' to this function
;; to fill `+eglot-auto-enable-modes' with all supported modes.
(defcustom +eglot-auto-enable-modes
  '(c++-mode c++-ts-mode c-mode c-ts-mode python-mode python-ts-mode rust-mode
    rust-ts-mode cmake-mode js-mode js-ts-mode typescript-mode
    typescript-ts-mode json-mode json-ts-mode js-json-mode)
  "Modes for which Eglot can be automatically enabled by `+eglot-auto-enable'."
  :group 'ematrix-prog
  :type '(repeat symbol))

(defun +eglot--ensure-maybe-h ()
  "Maybe auto start Eglot if the current mode is in `+eglot-auto-enable-modes'."
  (when (apply #'provided-mode-derived-p (append (list major-mode) +eglot-auto-enable-modes))
    (eglot-ensure)))

(defun +eglot-auto-enable ()
  "Auto-enable Eglot in configured modes in `+eglot-auto-enable-modes'."
  (interactive)
  (add-hook 'after-change-major-mode-hook #'+eglot--ensure-maybe-h)
  (remove-hook 'after-change-major-mode-hook #'+lsp--ensure-maybe-h))

(defun +eglot-use-on-all-supported-modes (mode-list)
  "Add all modes in MODE-LIST to `+eglot-auto-enable-modes'."
  (dolist (mode-def mode-list)
    (let ((mode (if (listp mode-def) (car mode-def) mode-def)))
      (cond
       ((listp mode) (+eglot-use-on-all-supported-modes mode))
       (t
        (when (and (not (eq 'clojure-mode mode)) ; prefer cider
                   (not (eq 'lisp-mode mode))    ; prefer sly
                   (not (eq 'scheme-mode mode))) ; prefer geiser
          (add-to-list '+eglot-auto-enable-modes mode)))))))

(defun +eglot-register (modes &rest servers)
  "Register MODES with LSP SERVERS.
Examples:
  (+eglot-register 'vhdl-mode \"vhdl_ls\")
  (+eglot-register 'lua-mode \"lua-language-server\" \"lua-lsp\")
  (+eglot-register '(c-mode c++-mode) '(\"clangd\" \"--clang-tidy\" \"-j=12\") \"ccls\")"
  (declare (indent 0))
  (with-eval-after-load 'eglot
    (let ((orig-val (assoc modes eglot-server-programs (lambda (s1 s2) (seq-intersection (ensure-list s1) (ensure-list s2)))))
          (contact (if (length> servers 1) (eglot-alternatives (ensure-list servers)) (ensure-list (car servers)))))
      (if (null orig-val) ; not present, add it
          (add-to-list 'eglot-server-programs (cons modes contact))
        (unless (equal (car orig-val) modes)
          (setcar orig-val modes))
        (setcdr orig-val contact)))))



;;; Binary files tweaks

;; (add-to-list 'magic-fallback-mode-alist '(+binary-hexl-buffer-p . +binary-hexl-mode-maybe) t))

(defcustom +binary-hexl-enable t
  "Enable or disable opening suitable files in `hexl-mode'."
  :group 'ematrix-binary
  :type 'boolean)



;;; Project tweaks

(defcustom +project-scan-dir-paths nil
  "A list of paths to scan and add to known projects list.
It can be a list of strings (paths) or a list of (cons \"~/path\" recursive-p) to scan directories recursively."
  :group 'ematrix-project
  :type '(repeat (choice directory (cons directory boolean))))

(defun +project-scan-for-projects (&optional dir)
  "Scan and remember projects under DIR or `+project-scan-dir-paths'."
  (interactive)
  (dolist (cons-dir (or dir +project-scan-dir-paths))
    (let* ((cons-dir (ensure-list cons-dir))
           (root-dir (car cons-dir))
           (recursive (cdr cons-dir))
           (sub-dirs (and (file-directory-p root-dir) (+directory-subdirs root-dir))))
      (dolist (dir sub-dirs)
        (project-remember-projects-under dir recursive)))))

(defcustom +super-project-root-markers '(".super-project" ".super-project.el" ".repo" ".code-workspace" ".workspace")
  "List of super-project markers."
  :group 'ematrix-project
  :type '(repeat string))

(defun +project-super-project-try-or-fail (dir)
  "Find super-project root starting from DIR."
  (if-let* ((root (cl-some (apply-partially #'locate-dominating-file dir) +super-project-root-markers)))
      (cons 'local root)
    (user-error "It doesn't seem that we are in a super-project")))

(defun +super-project-define-commands (package &rest commands)
  "Define PACKAGE's COMMANDS for super-project context."
  (declare (indent 1))
  (with-eval-after-load package
    (let (form)
      (dolist (command commands)
        (let* ((new-cmd (intern (format "%s%s-super-project" (if (string-prefix-p "+" (format "%s" command)) "" "+") command))))
          (push
           `(defalias ',new-cmd
              (lambda ,(help-function-arglist command t)
                ,(interactive-form command) ; Use the same interactive form as the original command
                (let ((project-find-functions '(+project-super-project-try-or-fail)))
                 (call-interactively (function ,command))))
              ,(format "Call `%s' in a super-project context." command))
           form)))
      (eval (macroexp-progn form)))))



;;; Proxy
;;; =====

(defun ematrix-get-enabled-proxies ()
  "Get a list of enabled proxies."
  (cl-loop
   for prox in '("no" "ftp" "http" "https")
   append (cl-loop for fn in '(downcase upcase)
                   collect (cons (funcall fn prox) (getenv (funcall fn (format "%s_proxy" prox)))))))

(defun ematrix-set-enabled-proxies (proxies)
  "Set PROXIES."
  (cl-loop
   for prox in proxies
   do (cl-loop
       for fn in '(upcase downcase)
       do (cons (funcall fn (car prox)) (setenv (funcall fn (format "%s_proxy" (car prox))) (cdr prox))))))

(defun ematrix-enable-proxy (proxies)
  "Set *_proxy Linux environment variables from PROXIES."
  (interactive (list ematrix-proxies))
  (ematrix-set-enabled-proxies proxies))

(defun ematrix-disable-proxy ()
  "Unset *_proxy Linux environment variables."
  (interactive)
  (ematrix-set-enabled-proxies (mapcar (lambda (a) (list (car a))) (ematrix-get-enabled-proxies))))

(defmacro +with-proxies (&rest body)
  "Execute BODY with proxies enabled from `ematrix-proxies'."
  `(let ((old-proxies (ematrix-get-enabled-proxies)))
    (ematrix-enable-proxy ematrix-proxies)
    ,@body
    (ematrix-enable-proxy old-proxies)))

(defmacro +with-no-proxies (&rest body)
  "Execute BODY with proxies disabled."
  `(let ((old-proxies (ematrix-get-enabled-proxies)))
    (ematrix-disable-proxy)
    ,@body
    (ematrix-enable-proxy old-proxies)))



;;; Keybinding macros
;;; =================

;; TEMP: These macros are specific to `evil' and `general'. Ematrix moved since
;; v7.0.0 to a more classic (non Evil-based) keybindings. These macros are left
;; for now to avoid breaking users configurations, they might be deleted in a
;; future release.
;; PERF+HACK: At some point, Ematrix startup become too slow, specially when
;; initializing `general' and `evil'. After trying several configurations, I
;; figured out that deferring `general' solves the issue. However, deferring
;; `general' means that we cannot define the keybindings when loading other
;; packages, i.e. before `general' gets loaded and the Ematrix definers (i.e.
;; `+ematrix--internal-map!', `+ematrix--internal-map-local!', ...) are made
;; available. We overcome this by defining these macros to define the
;; keybindings by wrapping the actual definition in a `with-eval-after-load'
;; block to be evaluated only after `general' gets loaded and configured and the
;; definers are ready (See `me-keybindings').
(defmacro +map! (&rest args)
  "A wrapper around `+ematrix--internal-map!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  (let (pkg mod)
    (when (eq (car args) :package)
      (setq pkg (cadr args)
            args (cddr args))
      (when (eq (car args) :module)
        (setq mod (cadr args)
              args (cddr args))))
    `(unless ,(when pkg (append (list '+package-disabled-p (list 'quote pkg)) (when mod (list (list 'quote mod)))))
      (with-eval-after-load 'me-general-ready
       (+ematrix--internal-map! ,@args)))))

(defmacro +map-local! (&rest args)
  "A wrapper around `+ematrix--internal-map-local!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  (let (pkg mod)
    (when (eq (car args) :package)
      (setq pkg (cadr args)
            args (cddr args))
      (when (eq (car args) :module)
        (setq mod (cadr args)
              args (cddr args))))
    `(unless ,(when pkg (append (list '+package-disabled-p (list 'quote pkg)) (when mod (list (list 'quote mod)))))
      (with-eval-after-load 'me-general-ready
       (+ematrix--internal-map-local! ,@args)))))

;; Wrappers around `general's VIM like definers, needs `general-evil-setup' to
;; be executed (See `me-keybindings')
(defmacro +nmap! (&rest args)
  "A wrapper around `general-nmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nmap ,@args)))

(defmacro +vmap! (&rest args)
  "A wrapper around `general-vmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-vmap ,@args)))

(defmacro +mmap! (&rest args)
  "A wrapper around `general-mmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-mmap ,@args)))

(defmacro +imap! (&rest args)
  "A wrapper around `general-imap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-imap ,@args)))

(defmacro +emap! (&rest args)
  "A wrapper around `general-emap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-emap ,@args)))

(defmacro +omap! (&rest args)
  "A wrapper around `general-omap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-omap ,@args)))

(defmacro +rmap! (&rest args)
  "A wrapper around `general-rmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-rmap ,@args)))

(defmacro +iemap! (&rest args)
  "A wrapper around `general-iemap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-iemap ,@args)))

(defmacro +nvmap! (&rest args)
  "A wrapper around `general-nvmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nvmap ,@args)))



;;; Data serialization

(defcustom +serialized-symbols-directory (concat ematrix-local-dir "+serialized-symbols/")
  "Default directory to store serialized symbols."
  :group 'ematrix-core
  :type 'directory)

(defun +serialize-sym (sym &optional dir filename-format)
  "Serialize SYM to DIR.
If FILENAME-FORMAT is non-nil, use it to format the file name (ex.
\"file-%s.el\"). Return the written file name, or nil if SYM is not bound."
  (when (boundp sym)
    (let ((out-file (expand-file-name
                     (format (or filename-format "%s.el") (symbol-name sym))
                     (or dir +serialized-symbols-directory))))
      (+log! "Saving `%s' to file \"%s\"" (symbol-name sym) (abbreviate-file-name out-file))
      (with-temp-buffer
        (prin1 (eval sym) (current-buffer))
        (+shutup! (write-file out-file)))
      out-file)))

(defun +deserialize-sym (sym &optional dir mutate filename-format)
  "Deserialize SYM from DIR, if MUTATE is non-nil, assign the object to SYM.
If FILENAME-FORMAT is non-nil, use it to as a format (ex. \"file-%s.el\").
Return the deserialized object, or nil if the SYM.el
file dont exist."
  (let ((in-file (expand-file-name
                  (format (or filename-format "%s.el") (symbol-name sym))
                  (or dir +serialized-symbols-directory)))
        res)
    (when (file-exists-p in-file)
      (+log! "Loading `%s' from file \"%s\"" sym (abbreviate-file-name in-file))
      (with-temp-buffer
        (insert-file-contents in-file)
        (goto-char (point-min))
        (ignore-errors (setq res (read (current-buffer)))))
      (when mutate (set sym res)))
    res))



;;; Persistent & per-project scratch buffers

(defvar +scratch-default-file "__default"
  "The default file name for a project-less scratch buffer.

Will be saved in `+scratch-dir'.")

(defvar +scratch-dir (concat ematrix-local-dir "pscratch/")
  "Where to save persistent scratch buffers.")

(defvar +scratch-initial-major-mode nil
  "What major mode to start fresh scratch buffers in.

Scratch buffers preserve their last major mode, however, so this only affects
the first, fresh scratch buffer you create. This accepts:

  t           Inherits the major mode of the last buffer you had selected.
  nil         Uses `fundamental-mode'
  MAJOR-MODE  Any major mode symbol")

(defvar +scratch-buffers nil
  "A list of active scratch buffers.")

(defvar +scratch-current-project nil
  "The name of the project associated with the current scratch buffer.")
(put '+scratch-current-project 'permanent-local t)

(defvar +scratch-buffer-created-hook nil
  "The hooks to run after a scratch buffer is created.")

(defun +scratch-load-persistent-scratch-buffer (&optional project-name)
  (setq-local +scratch-current-project (or project-name +scratch-default-file))
  (let ((scratch-file (expand-file-name (concat +scratch-current-project ".el") +scratch-dir)))
    (make-directory +scratch-dir t)
    (when (file-readable-p scratch-file)
      (+log! "Reading persistent scratch from %s" scratch-file)
      (cl-destructuring-bind (content point mode)
          (with-temp-buffer
            (save-excursion (insert-file-contents scratch-file))
            (read (current-buffer)))
        (erase-buffer)
        (funcall mode)
        (insert content)
        (goto-char point)
        t))))

(defun +scratch-buffer (&optional dont-restore-p mode directory proj-name)
  "Return a scratchpad buffer in major MODE.

When DONT-RESTORE-P, do not load the previously saved persistent buffer. Load
persistent buffer dedicated to PROJ-NAME when provided.

When provided, set the `default-directory' to DIRECTORY."
  (let* ((buff-name (if proj-name (format "*pscratch:%s*" proj-name) "*pscratch*"))
         (pscratch-buff (get-buffer buff-name)))
    (with-current-buffer (or pscratch-buff (get-buffer-create buff-name))
      (setq-local default-directory (or directory default-directory)
                  so-long--inhibited t)
      (if dont-restore-p
          (erase-buffer)
        (unless pscratch-buff
          (+scratch-load-persistent-scratch-buffer proj-name)
          (when (and (eq major-mode 'fundamental-mode) (functionp mode))
            (funcall mode))))
      (cl-pushnew (current-buffer) +scratch-buffers)
      (satch-add-hook '(window-buffer-change-functions window-selection-change-functions server-visit-hook) #'+scratch-persist-buffers-h nil nil :transient t)
      (add-hook 'kill-buffer-hook #'+scratch-persist-buffer-h nil 'local)
      (run-hooks '+scratch-buffer-created-hook)
      (current-buffer))))

;; Persistent scratch buffer

(defun +scratch-persist-buffer-h (&rest _)
  "Save the current buffer to `+scratch-dir'."
  (let ((content (buffer-substring-no-properties (point-min) (point-max)))
        (curr-point (point))
        (mode major-mode))
    (with-temp-file (expand-file-name (concat (or +scratch-current-project +scratch-default-file) ".el") +scratch-dir)
      (prin1 (list content curr-point mode) (current-buffer)))))

(defun +scratch-persist-buffers-h (&rest _)
  "Save all scratch buffers to `+scratch-dir'."
  (setq +scratch-buffers (cl-delete-if-not #'buffer-live-p +scratch-buffers))
  (dolist (buffer +scratch-buffers)
    (with-current-buffer buffer (+scratch-persist-buffer-h))))

(defun +scratch-persist-buffers-after-switch-h (&rest _)
  "Kill scratch buffers when they are no longer visible, saving them to disk."
  (unless (cl-some #'get-buffer-window +scratch-buffers)
    (mapc #'kill-buffer +scratch-buffers)
    (remove-hook '+switch-buffer-hook #'+scratch-persist-buffers-after-switch-h)))

(unless noninteractive
  (add-hook 'kill-emacs-hook #'+scratch-persist-buffers-h))

;; Commands

(defun +scratch-open-buffer (&optional arg project-p same-window-p)
  "Pop up a persistent scratch buffer.

If passed the prefix ARG, do not restore the last scratch buffer.
If PROJECT-P is non-nil, open a persistent scratch buffer associated with the
current project. When SAME-WINDOW-P is non-nil, open in the current window."
  (interactive "P")
  (let ((proj (and project-p (project-current))))
    (funcall
     (if same-window-p #'switch-to-buffer #'pop-to-buffer)
     (+scratch-buffer
      arg
      (cond ((eq +scratch-initial-major-mode t)
             (unless (or buffer-read-only ;; not a read-only buffer
                         (derived-mode-p 'special-mode) ;; not in some sort of special mode (view only)
                         (string-match-p "^ ?\\*" (buffer-name))) ;; not a hidden buffer
               major-mode))
            ((symbolp +scratch-initial-major-mode)
             +scratch-initial-major-mode))
      (and proj (project-root proj))
      (and proj (project-name proj))))))

(defun +switch-to-scratch-buffer (&optional arg project-p)
  "Like `+scratch-open-buffer', but switch to it in the current window.

If passed the prefix ARG, do not restore the last scratch buffer. If PROJECT-P,
open the persistent buffer dedicated to the current project."
  (interactive "P")
  (+scratch-open-buffer arg project-p 'same-window))

(defun +scratch-open-project-scratch-buffer (&optional arg same-window-p)
  "Opens the (persistent) project scratch buffer in a popup.

If passed the prefix ARG, do not restore the last scratch buffer. When
SAME-WINDOW-P is non-nil, open in the same window."
  (interactive "P")
  (+scratch-open-buffer arg 'project same-window-p))

(defun +scratch-switch-to-project-scratch-buffer (&optional arg)
  "Like `+scratch-open-project-scratch-buffer', but switch in the current window.

If passed the prefix ARG, do not restore the last scratch buffer."
  (interactive "P")
  (+scratch-open-project-scratch-buffer arg 'same-window))

(defun +scratch-revert-scratch-buffer ()
  "Revert scratch buffer to last persistent state."
  (interactive)
  (unless (string-match-p "^\\*pscratch" (buffer-name))
    (user-error "Not in a scratch buffer"))
  (when (+scratch-load-persistent-scratch-buffer +scratch-current-project)
    (message "Reloaded scratch buffer")))

(defun +scratch-delete-persistent-scratch-file (&optional arg)
  "Deletes a scratch buffer file in `+scratch-dir'.

If prefix ARG, delete all persistent scratches."
  (interactive)
  (if arg
      (progn
        (delete-directory +scratch-dir t)
        (message "Cleared %S" (abbreviate-file-name +scratch-dir)))
    (make-directory +scratch-dir t)
    (let ((file (read-file-name "Delete scratch file > " +scratch-dir "scratch")))
      (if (not (file-exists-p file))
          (message "%S does not exist" (abbreviate-file-name file))
        (delete-file file)
        (message "Successfully deleted %S" (abbreviate-file-name file))))))

(defun +scratch-replace-with-persistent-scratch (&optional arg project-p)
  "Replace the *scratch* buffer with a persistent one.

ARG and PROJECT-P are passed to `+scratch-open-buffer'."
  (interactive "P")
  (when-let* ((buf (current-buffer))
              (s (get-buffer "*scratch*")))
    ;; Load the default persistent scratch buffer
    (+scratch-open-buffer arg project-p 'same-window)
    ;; Kill the Emacs' default scratch buffer
    (kill-buffer s)
    ;; Switch to the previous buffer, unless it has been killed (we was in *scratch*) or it is a hidden buffer
    (when (and (buffer-live-p buf) (string-match-p "^[^ ]" (buffer-name buf)))
      (switch-to-buffer buf))))



;;; Font and script settings

(defcustom ematrix-fonts-plist
  '(:default
    ((:family "JetBrainsMono Nerd Font" :height 130)
     (:family "Martian Mono" :height 100)
     (:family "Iosevka Fixed Curly Slab" :height 110)
     (:family "Iosevka Comfy Fixed" :height 110)
     (:family "Iosevka Fixed Curly" :height 110)
     (:family "Iosevka Comfy Motion Fixed" :height 110)
     (:family "Iosevka" :height 110)
     (:family "Iosevka Comfy" :height 110)
     (:family "Cascadia Code" :height 110)
     (:family "Fira Code" :height 110)
     (:family "Jetbrains Mono" :height 100)
     (:family "Hack" :height 110)
     (:family "Roboto Mono" :height 100)
     (:family "SF Mono" :height 110)
     (:family "Source Code Pro" :height 110)
     (:family "Menlo" :height 110)
     (:family "Monaco" :height 110)
     (:family "Ubuntu Mono" :height 110)
     (:family "DejaVu Sans Mono" :height 110)
     (:family "Consolas" :height 110))
    :fixed-pitch
    ((:inherit default))
    :fixed-pitch-serif
    ((:inherit default))
    :variable-pitch
    ("Lato"
     "Roboto"
     "Inter"
     "San Francisco"
     "Helvetica Neue"
     "Helvetica"
     "Ubuntu"
     "Liberation Sans"
     "Segoe UI")
    :symbol
    ((:family "Segoe UI Symbol" :prepend t)
     (:family "Symbola" :prepend t)
     (:family "Symbol" :prepend t))
    :emoji
    ((:family "Noto Color Emoji" :prepend t)
     (:family "Apple Color Emoji" :prepent t)
     (:family "Segoe UI Emoji" :prepend t)
     (:family "Quivira" :prepend t))
    ;; Arabic script
    :arabic
    ("Amiri Typewriter"
     "KacstOne"
     "Greta Arabic"
     "Scheherazade"
     "Koodak"
     (:family "Amiri" :scale 0.9))
    ;; Chinese script
    :han
    ((:family "LXGW Neo Xihei" :scale 1.3)
     (:family "WenQuanYi Micro Hei Mono" :scale 1.3)
     (:family "LXGW WenKai Screen" :scale 1.3)
     (:family "LXGW WenKai Mono" :scale 1.3)
     (:family "PingFang SC" :scale 1.3)
     (:family "Microsoft Yahei UI" :scale 1.3)
     (:family "Simhei" :scale 1.3)))
  "Ematrix fonts used by `+setup-fonts'.

The function checks and enables the first available font from these defined in
this plist. This variable can be customized to set font specs for specific Emacs
faces or to enable some language-specific fonts. The plist keywords are either
face names or script names expressed as keywords (with the \":\" prefix).

For example to set `default' face, use `:default', to set the `mode-line' face,
use `:mode-line', and so on. The parameters for each font in these cases (ie.
for face names) are used in the `custom-theme-set-faces' function, so you can
pass any specs (key value pairs) supported by `custom-theme-set-faces' (like
`:weight', `:slant', `:foreground', ...). A list of supported keywords are
available in the variable `+face-attributes'.

You can also setup some language-specific fonts. All scripts supported by Emacs
can be found in `+known-scripts'. The keyword in this plist will be the script
name expressed as a keyword, for example, for `latin' use `:latin', for `arabic'
use `:arabic', for `emoji' use `:emoji', and so on. In this case, the parameters
are used with `set-fontset-font', so you can send any key value pair supported
by `set-fontset-font'. A list of supported keywords in this case is available in
`+font-spec-keywords'.

The value of the extra `:prepend' keyword is passed the last argument to
`set-fontset-font'. The value of the extra `:scale' keyword can be used to set a
scaling factor for the font in Emacs' `face-font-rescale-alist'. See the
`+setup-fonts' implementation for more details."
  :group 'ematrix-ui
  :type 'plist)

(defconst +known-scripts (mapcar #'car script-representative-chars)
  "Supported scripts, like `latin', `arabic', `han', and so on.")

(defconst +face-attributes
  '(:family :foundry :width :height :weight :slant :foreground
    :distant-foreground :background :underline :overline :strike-through :box
    :inverse-video :stipple :font :inherit :extend)
  "Arguments accepted by the `set-face-attribute' function.")

(defconst +font-spec-keywords
  '(:family :foundry :width :weight :slant :adstyle :registry :dpi :size
    :spacing :avgwidth :name :script :lang :otf)
  "Arguments accepted by the `font-spec' function.")

(defun +font--get-valid-args (script-or-face font)
  "Get valid arguments from FONT for SCRIPT-OR-FACE."
  (if (stringp font)
      `(:family ,font)
    (apply
     #'append
     (mapcar (lambda (a) (list a (plist-get font a)))
             (cl-intersection
              (+plist-keys font)
              (if (memq script-or-face +known-scripts) +font-spec-keywords +face-attributes))))))

(defun +font-installed-p (font-family)
  "Check if FONT-FAMILY is installed on the system."
  (and font-family (member font-family (and (fboundp 'font-family-list) (font-family-list))) t))

(defun +apply-font-or-script (script-or-face)
  "Set font for SCRIPT-OR-FACE from `ematrix-fonts-plist'."
  (catch 'done
    (dolist (font (plist-get ematrix-fonts-plist (intern (format ":%s" script-or-face))))
      (let* ((spec (+font--get-valid-args script-or-face font))
             (scale (and (plistp font) (plist-get font :scale)))
             (prependp (and (plistp font) (plist-get font :prepend)))
             (family (plist-get spec :family))
             (scriptp (memq script-or-face +known-scripts)))
        (when (or (not family) (+font-installed-p family))
          (if scriptp
              (set-fontset-font t script-or-face (apply #'font-spec spec) nil prependp)
            (custom-theme-set-faces 'user `(,script-or-face ((t ,spec)))))
          (when (and scale family)
            (add-to-list 'face-font-rescale-alist (cons family scale)))
          (+log! "Settinng %s `%s' to `%s'" (if scriptp "script" "face") script-or-face spec)
          (throw 'done spec))))))

;; Inspired by: github.com/seagle0128/.emacs.d/blob/master/custom-example.el
(defun +setup-fonts ()
  "Setup fonts."
  (interactive)
  (when (display-graphic-p)
    (mapc #'+apply-font-or-script
          (reverse
           (mapcar (lambda (k) (intern (substring (symbol-name k) 1)))
                   (+plist-keys ematrix-fonts-plist))))

    ;; Set the tooltip font accordingly
    (when-let* ((font (car (and (fboundp 'fontset-list) (fontset-list)))))
      (setq tooltip-frame-parameters (+alist-set 'font font tooltip-frame-parameters))))

  ;; Run hooks
  (run-hooks 'ematrix-after-setup-fonts-hook))

(+add-hook! (window-setup server-after-make-frame) #'+setup-fonts)


(provide 'me-lib)
;;; me-lib.el ends here
#+end_src
